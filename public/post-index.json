{
  "retrospect/aflow": {
    "excerpt": "\nAflow는 기존의 레포지토리 트리 ASCII 변환 프로젝트를 확장하여, AI를 활용해 파일/폴더 구조를 분석하고 아키텍처 다이어그램으로 변환하는 프로젝트다.  \n오픈소스에 기여하면서 코드를 열어보기 전에 어떤 구조인지 이해가 안되면 어떤 기능을 하는 코드인지 이해하기 어려웠던 적이 많았다.\nREADME나 기술문서에 친절하게 아키텍쳐가 보여주는 경우도 있지만 없는 경우가 더 많았고, Claude에 트리 구조를 넣으면 생소한 프로젝트라도 맥락을 빠르게 이해할 수 있었기 때문에 자주 사용하게 되었다.\n\n![Tauri 프로젝트 기술문서에 나와있는 아키텍쳐 예시](https://github.com/user-attachments/assets/6c74b6fa-b4e5-4d63-8478-e313cfa52b74)\n\nClaude는 Anthropic이 개발한 AI 모델로, 아티팩트 기능을 통해 Mermaid.js를 사용해 레포지토리 트리 구조를 넣으면 다이어그램으로 보여주는 기능이 있었다.\n하지만 Mermaid 문법을 보여줄 때 3번 중 1번은 오류가 발생하고 매번 트리구조를 복사해서 붙여넣기를 해야하는 불편함도 있었다.\n이 기능을 확장해서 GitHub의 레포지토리 트리를 매번 복사/붙여넣기할 필요없이 다이어그램으로 보여주는 자동화 도구를 만들고 싶었다.\n\n그래서 3가지 중점을 두고 프로젝트를 계획했다.\n\n1. 트리 구조를 복사해서 매번 붙여넣기를 하지 않도록 자동화\n2. 일관성 있는 Mermaid 문법으로 출력\n3. GitHub에서 비공개 레포지토리도 가져와 다이어그램으로 출력\n\n",
    "title": "Aflow 프로젝트 회고",
    "description": "2024년 12월부터 2025년 1월까지 진행된 Aflow 프로젝트 회고입니다.",
    "createdAt": "2025-02-03T09:00:00+09:00",
    "updatedAt": "2025-02-03T09:00:00+09:00",
    "tags": [
      "Retrospect"
    ]
  },
  "retrospect/blog-migrate": {
    "excerpt": "\n처음 vue-django를 이용해서 기술 블로그를 사용하면서 옵시디언으로 글을 작성해서 블로그에 업로드하고\nGitHub의 TIL 리포지토리에 쓴 글들을 백업하는 과정이 있었는데 업로드 과정이 비효율적이라는 생각이 들었습니다.\n점점 공부한 내용을 기록하고 업로드하는 과정이 즐겁지 않아서 업로드 기간이 늘어나고 점점 글을 쓰지 않게 되었습니다.\n그래서 업로드 기간이 늘어난 것에 대해 고민을 하다가 vue-django 블로그를 정리하고 GitHub Pages로 블로그를 변경했습니다.\n블로그를 바꾸게된 과정과 생각을 이번 글에서 정리해보겠습니다.\n\n",
    "title": "블로그 이전 후기",
    "description": "",
    "createdAt": "2023-10-12T09:00:00+09:00",
    "updatedAt": "2023-10-12T09:00:00+09:00",
    "tags": [
      "Retrospect"
    ]
  },
  "retrospect/fit-bot-ec2-instance-error": {
    "excerpt": "\n카카오톡 챗봇 서비스 **GarminFitBot**을 운영하면서, 어느 날 사용자로부터 \"서버 오류\" 메시지를 받았습니다. 확인해보니 서비스는 실제로 멈춰 있었고, AWS 콘솔에 \"인스턴스 연결성 검사 실패\" 경고가 떠 있었습니다.\n\n![EC2 인스턴스의 연결성 검사 실패 메세지](/images/ec2-instance-error.png)\n\n이번 글에서는 그때 겪었던 **메모리 부족 장애의 원인과 대응 과정**, 그리고 이후 **시스템을 개선하기 위해 시도한 내용들**을 정리해보았습니다.\n\n",
    "title": "예상치 못한 서버 다운, 그리고 메모리 부족 장애 대응기",
    "description": "",
    "createdAt": "2025-04-09T09:00:00+09:00",
    "updatedAt": "2025-04-09T09:00:00+09:00",
    "tags": [
      "GarminFitBot",
      "Project"
    ]
  },
  "retrospect/garmin-fit-bot": {
    "excerpt": "\n<div style=\"display: flex; gap: 1rem; justify-content: center;\">\n  <img src=\"https://raw.githubusercontent.com/zamoca42/GarminFitBot/main/frontend/src/lib/images/screenshots/chatbot-analysis-health.png\" alt=\"AI 분석 요청\" width=\"45%\"/>\n  <img src=\"https://raw.githubusercontent.com/zamoca42/GarminFitBot/main/frontend/src/lib/images/screenshots/result-analysis-health.png\" alt=\"AI 분석 결과\" width=\"45%\"/>\n</div>\n\n최근 '가민 핏봇(Garmin FitBot)' 프로젝트를 진행하면서 겪었던 고민과 문제들, 그리고 그 과정에서의 경험을 공유하고자 합니다.\n\n",
    "title": "가민 핏봇(GarminFitBot) 개발 후기",
    "description": "",
    "createdAt": "2025-04-02T09:00:00+09:00",
    "updatedAt": "2025-04-02T09:00:00+09:00",
    "tags": [
      "GarminFitBot",
      "Project"
    ]
  },
  "retrospect/next-blog-migrate": {
    "excerpt": "\nVuepress를 이용한 블로그를 사용하다가 여러 가지 문제에 부딪히게 되었다.\n처음에는 블로그에 최적화된 레이아웃과 마크다운을 사용하는 것이 편했으나,\n의존성 충돌이 빈번하게 일어나고 제한적인 플러그인과 트러블 슈팅에 대한 정보가 부족해 한계를 느껴 Next.js로 변경을 고려하게 되었다.\n\n이번 포스트에서는 Next.js로 블로그를 이전하기까지 과정을 정리하고 공유해보려고 한다.\n\n",
    "title": "Next.js 블로그로 이전 후기",
    "description": "Vuepress에서 Next.js로 블로그를 이전한 후기입니다.",
    "createdAt": "2024-07-20T09:00:00+09:00",
    "updatedAt": "2024-07-20T09:00:00+09:00",
    "tags": [
      "Retrospect"
    ]
  },
  "retrospect/ohoo-admin": {
    "excerpt": "\n오후스튜디오에서 일하시는 개발자분과 멘토링하면서 실제 DB테이블을 가지고 회원 관리 페이지를 만들어보자고\n제안해주셔서 회원 정보, 요금제 정보를 불러오는 페이지를 만들어봤습니다.\n\n",
    "title": "오후스튜디오 회원 관리 페이지 개발 후기",
    "description": "",
    "createdAt": "2023-10-02T09:00:00+09:00",
    "updatedAt": "2023-10-02T09:00:00+09:00",
    "tags": [
      "Retrospect"
    ]
  },
  "retrospect/oss-auth-js": {
    "excerpt": "",
    "title": "오픈소스 기여: NextAuth.js 에서 객체 병합 함수 개선하기",
    "description": "",
    "createdAt": "2024-09-30T09:00:00+09:00",
    "updatedAt": "2024-09-30T09:00:00+09:00",
    "tags": [
      "Authjs",
      "Open-Source"
    ]
  },
  "retrospect/oss-gitbutler-binary": {
    "excerpt": "\n> 관련 이슈 1: https://github.com/gitbutlerapp/gitbutler/issues/2752  \n> 관련 이슈 2: https://github.com/gitbutlerapp/gitbutler/issues/3093\n\n이번 후기는 GitButler에서 바이너리 파일(이미지, 폰트파일 등)을 미리보기 기능을 구현한 것에 대한 후기입니다.\n\n![UI에서 미리보기 없이 Binary content not shown을 출력한다](https://github.com/user-attachments/assets/bc6269bd-14c0-4874-afc5-526d8ca82dfa)\n\n관련 이슈를 살펴보면 바이너리 파일을 미리보기 기능을 구현하는 것에 대한 이슈가 있었습니다.  \nUI에서 이미지는 미리보기 기능, 이미지 외의 파일에 대한 사이즈 정보를 보여주는 기능을 구현하는 것이 목표였습니다.\n\n",
    "title": "GitButler - 이미지 미리보기 기능 기여 후기",
    "description": "",
    "createdAt": "2024-10-21T09:00:00+09:00",
    "updatedAt": "2024-10-21T09:00:00+09:00",
    "tags": [
      "GitButler",
      "Git",
      "Open-Source"
    ]
  },
  "retrospect/oss-gitbutler-tauri-linux-window": {
    "excerpt": "\n## 들어가며\n\n우연히 WSL 환경에서 GitButler를 실행하던 중 앱을 최대화하는 순간 종료되는 현상을 발견했습니다. 이 문제는 단순한 앱 버그가 아닌 Tauri 프레임워크 자체의 문제였고, 수많은 앱에 영향을 미치는 이슈였습니다.  \n이 글에서는 문제 발견부터 해결까지의 과정과 겪었던 어려움들을 공유하고자 합니다.  \n\n",
    "title": "리눅스 환경 GitButler 앱 최대화 버그 분석과 해결 과정",
    "description": "",
    "createdAt": "2024-10-20T09:00:00+09:00",
    "updatedAt": "2024-10-20T09:00:00+09:00",
    "tags": [
      "GitButler",
      "Linux",
      "Open-Source"
    ]
  },
  "retrospect/oss-node-cron": {
    "excerpt": "\n## 들어가며\n\n최근 주간 230만 다운로드를 기록하는 Node.js 패키지인 node-cron에 비동기 처리 기능을 추가하는 PR을 진행했습니다.  \n처음에는 단순히 기술적인 문제 해결에 집중했지만, 과정을 거치면서 많은 사용자가 의존하는 패키지를 수정할 때의 고려사항과 책임에 대해 생각하게 되었습니다.  \n이 글에서는 비동기 작업을 제대로 처리하기 위한 기능을 추가하면서 겪었던 고민과 시행착오, 그리고 기존 사용자에게 영향을 주지 않으면서 새로운 기능을 통합하는 과정에 대한 경험을 공유하고자 합니다.\n\n",
    "title": "오픈소스 기여: node-cron 비동기 처리 개선 후기",
    "description": "",
    "createdAt": "2024-12-20T09:00:00+09:00",
    "updatedAt": "2024-12-20T09:00:00+09:00",
    "tags": [
      "node-cron",
      "Node.js",
      "Open-Source"
    ]
  },
  "retrospect/vue-django-blog": {
    "excerpt": "\n로봇공학, 인공지능 강의를 들으면서 파이썬에 관심을 가지게 되었고 파이썬으로 공부를 하면서 배운 것을 어떻게 적용해볼 수 있을지 고민했습니다.\n마침 인프런에서 vue-django 블로그 만들기가 눈에 들어왔고 만들어서 기술블로그로 사용할 생각으로 AWS에 배포까지 계획했습니다.\n\n",
    "title": "vue-django 블로그 개발 후기",
    "description": "",
    "createdAt": "2023-10-09T09:00:00+09:00",
    "updatedAt": "2023-10-09T09:00:00+09:00",
    "tags": [
      "Retrospect"
    ]
  },
  "js-ts/auth-js": {
    "excerpt": "\nAuth.js를 활용하여 개발하면서 세션(Session)과 JWT(JSON Web Token) 인증 방식에 대해 실제로 경험해 볼 수 있었다.\n두 방식 모두 쿠키를 사용하기에 각 방식의 특징과 사용 경험을 중심으로 정리해 보았다.\n\n## Auth.js 소개\n\n> 🌐 https://authjs.dev/getting-started\n\nAuth.js는 인증을 쉽게 구현할 수 있게 해주는 강력한 라이브러리다.  \nGoogle 로그인과 같은 OAuth나 이메일 인증 로그인을 지원하며, 세션 및 JWT 기반의 인증을 모두 구현할 수 있다.\n\n",
    "title": "Auth.js로 알아보는 세션과 JWT 인증 방식의 차이",
    "description": "",
    "createdAt": "2024-08-01T09:00:00+09:00",
    "updatedAt": "2024-08-01T09:00:00+09:00",
    "tags": [
      "JWT",
      "Session",
      "Next.js",
      "Auth.js"
    ]
  },
  "js-ts/date-fns": {
    "excerpt": "\nTODO 앱을 직접 만들어보면서 오늘 날짜를 기준으로 완료 여부를 확인할 수 있는 기능을 만들어보기 위해\n\ndate-fns 라이브러리를 사용했다.\n\n## startOfDay, endOfDay\n\ndate-fns의 startOfDay와 endOfDay 함수를 사용하면 Date 객체 기준\n\n날짜의 시작 시간과 완료 시간을 보여주는데\n\n오늘의 범위를 0시부터 23시 59분 기준으로 생각하고 함수를 사용하면 생각과 다른 결과가 나온다.\n\n",
    "title": "date-fns로 Date 객체 다루기",
    "description": "",
    "createdAt": "2024-04-23T09:00:00+09:00",
    "updatedAt": "2024-04-23T09:00:00+09:00",
    "tags": [
      "TypeScript",
      "JavaScript"
    ]
  },
  "js-ts/dom-vs-vdom": {
    "excerpt": "",
    "title": "Virtual DOM과 DOM 비교",
    "description": "React와 Svelte의 접근 방식 분석",
    "createdAt": "2025-04-29T09:00:00+09:00",
    "updatedAt": "2025-04-29T09:00:00+09:00",
    "tags": [
      "React",
      "Svelte"
    ]
  },
  "js-ts/node-readdir": {
    "excerpt": "\nNext.js 블로그 스타터를 시작하면 마크다운 포스트를 가져오는 로직은 `fs.readFileSync()`를 사용하여 컨텐츠 폴더 아래의 파일만 탐색하게 된다.\n\n```ts:lib/api.ts {15}\nimport { Post } from \"@/interfaces/post\";\nimport fs from \"fs\";\nimport matter from \"gray-matter\";\nimport { join } from \"path\";\n\nconst postsDirectory = join(process.cwd(), \"_posts\");\n\nexport function getPostSlugs() {\n  return fs.readdirSync(postsDirectory);\n}\n\nexport function getPostBySlug(slug: string) {\n  const realSlug = slug.replace(/\\.md$/, \"\");\n  const fullPath = join(postsDirectory, `${realSlug}.md`);\n  const fileContents = fs.readFileSync(fullPath, \"utf8\");\n  const { data, content } = matter(fileContents);\n\n  return { ...data, slug: realSlug, content } as Post;\n}\n//...\n```\n\n하지만 컨텐츠 폴더 내부에 하위 폴더가 존재하면 해당 폴더 내의 파일은 찾지 못하는 문제가 있다.\n\n",
    "title": "Node.js로 디렉토리 트리 탐색하기",
    "description": "fs.readdir의 recursive 옵션으로 모든 마크다운 파일 찾기",
    "createdAt": "2024-06-20T09:00:00+09:00",
    "updatedAt": "2024-06-20T09:00:00+09:00",
    "tags": [
      "Node.js",
      "TypeScript",
      "Next.js"
    ]
  },
  "js-ts/sidebar-sorting": {
    "excerpt": "\n블로그의 사이드바에서 현재 포스트가 가지고 있는 카테고리 폴더와 파일을 보여주려고 컴포넌트를 만들었는데,\n정렬 방식이 마음에 들지 않았다.\n\n이를 개선하기 위해 두 가지 목표를 설정했다.\n\n1. 숫자를 포함한 정렬 방식으로 변경\n2. 폴더를 파일보다 상위에 배치\n\n![자바스크립트 문자열 방식으로 정렬하고 폴더와 파일의 순서에 구분이 없었다.](https://github.com/Zamoca42/next-blog/assets/96982072/3743a624-545c-48c5-b341-342a722d8a97)\n\n",
    "title": "사이드바 정렬 개선하기",
    "description": "폴더, 파일을 문자열 정렬에서 개선해보자",
    "createdAt": "2024-06-28T09:00:00+09:00",
    "updatedAt": "2024-06-28T09:00:00+09:00",
    "tags": [
      "Node.js",
      "TypeScript",
      "Next.js"
    ]
  },
  "js-ts/next/blog-docsearch": {
    "excerpt": "\n블로그에 검색 기능이 없어서 한글 형태소 지원, 적은 비용, 쉬운 유지보수를 고려한 라이브러리 사용을 고민하다 Typesense와 Aloglia를 알게 되었다.\n\nAlgolia는 Vuepress나 공식문서 페이지에서 자주 볼 수 있었는데,\n한글 형태소 검색이 지원되고 프리티어로 한달에 요청횟수 10k, 지원 문서 수 100만개까지 적용되어서 사용해봤다.\n\n이번 포스트에서는 Next.js에서 문서 검색을 설정한 과정에서 겪은 일들을 정리하려고한다.\n\n",
    "title": "블로그에 검색 적용하기 - Docsearch",
    "description": "",
    "createdAt": "2024-07-02T09:00:00+09:00",
    "updatedAt": "2024-07-02T09:00:00+09:00",
    "tags": [
      "Aloglia",
      "Next.js",
      "TypeScript"
    ]
  },
  "js-ts/next/hot-reload": {
    "excerpt": "\nNextJS로 프로젝트를 진행하던 중에 [Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)\n를 설정해 모달창을 구현하다가 HotReload 에러를 만나게 되었다.\n\n![내가 겪은 에러와 완전히 같아서 참고링크의 사진을 첨부했다.](https://github.com/Zamoca42/blog/assets/96982072/9df58ab8-0822-4079-8e18-072df747b9fd)\n\nNext로 모달을 구현하게되면 Parallel Routes를 자주 사용하게 될텐데 같은 에러가 생기면 다시 해결하기 위해 기록으로 남겨두려고한다.\n\n",
    "title": "Next.js 14 - HotReload 에러",
    "description": "",
    "createdAt": "2024-06-12T09:00:00+09:00",
    "updatedAt": "2024-06-12T09:00:00+09:00",
    "tags": [
      "Next.js",
      "TypeScript"
    ]
  },
  "js-ts/next/lighthouse": {
    "excerpt": "\nNext.js 14 정적 블로그에서 성능 개선을 시도한 경험을 이번 포스트에서 정리하려고 한다.\n처음에는 웹 성능 측정 도구에 대해 잘 몰라 어떤 지표로 성능을 평가해야 할지 막막했다.\n\n## Lighthouse 도구 발견\n\n![초기 성능 진단 결과](https://github.com/user-attachments/assets/dbea020e-29f7-4ff0-9ccb-d1b175dd4716)\n\n웹 성능 최적화에 대해 검색하던 중 Google에서 제공하는 Lighthouse라는 도구를 알게 되었다.\nLighthouse는 웹페이지의 성능, 접근성, SEO 등 다양한 측면을 분석해주는 강력한 도구였다.\n\n![초기 진단 항목들 중 LCP와 FCP에 영향을 주는 항목이 눈에 띈다.](https://github.com/user-attachments/assets/2bdd2c27-9fe1-448b-a16f-346680ecf0a7)\n\n프로덕션 환경에서 실행 결과, Largest Contentful Paint(LCP)이 눈에 띄는데  \n진단 항목을 살펴보면 이미지가 주된 원인이였다.\n\n",
    "title": "Next.js 14 - Lighthouse로 웹페이지 성능 개선하기",
    "description": "",
    "createdAt": "2024-07-31T09:00:00+09:00",
    "updatedAt": "2024-07-31T09:00:00+09:00",
    "tags": [
      "Next.js",
      "Lighthouse"
    ]
  },
  "js-ts/next/markdown-plugin": {
    "excerpt": "\n정적 블로그를 만들 때 마크다운 파일을 사용하는 경우, 단순히 `<div>` 태그와 `dangerouslySetInnerHTML` 속성으로 정적 콘텐츠를 삽입할 수 있다.\n\n하지만 이 방법으로는 추가적인 커스터마이징이 어렵다.\n\n이를 해결하기 위해 `next-mdx-remote`와 같은 라이브러리와 `remark` 같은 플러그인을 사용하면 HTML 코드를 원하는 대로 수정할 수 있다.\n\nNext.js 공식 문서에서는 MDX를 이용한 정적 블로그 예시를 제공하고 있다.\n하지만 이미 마크다운 형식으로 포스트를 작성해왔기 때문에 MDX로 변환할 필요성을 느끼지 못했다. `next-mdx-remote`에서 옵션으로 `.md` format을 지원하지만\n설정하는 방법이 직관적이라는 생각이 들지 않아서 [react-markdown](https://github.com/remarkjs/react-markdown)\n을 사용하기로 결정했다.\n\n",
    "title": "마크다운 플러그인 세팅",
    "description": "마크다운 플러그인인 remark, rehype와 react-markdown에 대해 알아보자",
    "createdAt": "2024-07-26T09:00:00+09:00",
    "updatedAt": "2024-07-26T09:00:00+09:00",
    "tags": [
      "Next.js",
      "React",
      "Markdown"
    ]
  },
  "js-ts/next/prisma-token-schema-error": {
    "excerpt": "\nAuth.js는 NextJS 친화적으로 설계된 오픈소스 인증 라이브러리다.\n\nNextJS에서 간단한 설정만으로 OAuth나 이메일 인증 로직을 적용할 수 있어 편리하다.\n\n다만 커스터마이징을 하기에는 사용자가 내부로직을 알기 모호하고 문서가 복잡하고 불친절하다는 느낌을 받았다.\n\n그 예로 NextJS에서 Prisma를 이용해 구글 이메일 로그인을 구현하면서 겪은 에러에 대해 정리하려고 한다.\n\n해당 내용은 Auth.js v4에서 겪은 에러로 내용은 다음과 같다.\n\n```txt:에러내용\nUnknown arg `access_token` in data.access_token for type AccountUncheckedCreateInput. Did you mean `accessToken`?\n```\n\n",
    "title": "Auth.js v4 - Unknown arg `access_token`... 에러",
    "description": "",
    "createdAt": "2024-06-13T09:00:00+09:00",
    "updatedAt": "2024-06-13T09:00:00+09:00",
    "tags": [
      "Next.js",
      "Auth.js",
      "Prisma"
    ]
  },
  "js-ts/next/run-script-build-time": {
    "excerpt": "\n마크다운 컨텐츠를 활용한 블로그를 만들면서 포스트의 생성일과 수정일을 커밋 날짜를 기준으로 블로그에 보여주려고 했다.\n\ngit 명령어를 [node.js의 child_process](https://www.freecodecamp.org/korean/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/)\n로 실행하면서 개발서버에서는 이상없이 돌아갔으나...\n\nVercel에 배포 할때는 `.git` 레포지토리가 포함되지 않기 때문에 git 명령어를 사용할 수 없다고 한다.\n\n![vercel command failed](https://github.com/Zamoca42/blog/assets/96982072/4cdbfb40-d459-424a-966b-4794e5b13f90)\n\n",
    "title": "Next.js - 빌드 타임에 스크립트를 실행하는 방법",
    "description": "What's the recommended way to run a script at build time?",
    "createdAt": "2024-06-13T09:00:00+09:00",
    "updatedAt": "2024-06-13T09:00:00+09:00",
    "tags": [
      "Next.js",
      "Node",
      "Script"
    ]
  },
  "js-ts/next/seo": {
    "excerpt": "\n구글과 네이버 같은 검색엔진은 크롤링 봇이 있는데 크롤링 봇이 웹사이트와 웹페이지를 수집하고 등록시켜 검색하는 유저에게 노출한다.\nSEO(Search Engine Optimization)는 검색엔진 크롤링 봇에게 내 웹페이지를 수집하기 쉽도록 개선하는 작업을 말한다.  \nSEO를 직접 제공하는 블로그 서비스를 이용하는 것이 아닌 이상 자동으로 검색엔진에 등록되는일은 없으므로 SEO를 위한 작업이 필요하다.\n\nNext.js 14버전의 App router를 기준으로 진행한 SEO 작업들을 정리하려고 한다.\n\n",
    "title": "Next.js - SEO와 검색엔진 등록",
    "description": "",
    "createdAt": "2024-07-24T09:00:00+09:00",
    "updatedAt": "2024-07-24T09:00:00+09:00",
    "tags": [
      "SEO",
      "Next.js"
    ]
  },
  "js-ts/nest-js/api": {
    "excerpt": "\n![회원 정보 검색](https://github.com/Zamoca42/blog/assets/96982072/3cb4e5b5-b460-470e-8c80-f65a1502ed44)\n\n이렇게 클라이언트에서 회원아이디를 입력했을때 회원의 정보를 보여주려고합니다\n\n```json\n{\n  \"id\": \"sdfsdf333\",\n  \"phoneNumber\": \"+821099990001\",\n  \"email\": \"이메일@.com\",\n  \"businessName\": \"회사이름\",\n  \"businessItem\": \"사업\"\n}\n```\n\n",
    "title": "고객정보 API 만들기",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Project"
    ]
  },
  "js-ts/nest-js/class-transformer": {
    "excerpt": "\n요청 객체를 역직렬화 과정과 마찬가지로 클라이언트에 데이터를 전달할 때\n응답 객체를 인스턴스로 변환하는데 NestJS에서는 `class-transformer`를 사용한다.\n\n한 객체가 변경이 발생하면 해당 객체에 의존하는 다른 객체들도 변경해야 하기 때문에 이들의 변경 범위를 최소화 하기 위해 캡슐화를 사용한다.\n\n",
    "title": "응답 객체 직렬화하기",
    "description": "",
    "createdAt": "2023-12-23T09:00:00+09:00",
    "updatedAt": "2023-12-23T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Class-Transformer"
    ]
  },
  "js-ts/nest-js/class-validator": {
    "excerpt": "\n클라이언트에서 HTTP 요청시 JSON이나 쿼리스트링의 경우 클래스 인스턴스로 변환하는 역직렬화와 유효성 검사과정이 필요하다.\n\n이 부분은 `class-validator` 패키지가 필요하다.\n[`class-validator`][class-validator]는 데코레이터를 기반으로 Dto들의 검증을 담당한다.\n\n",
    "title": "요청 객체 역직렬화하기",
    "description": "",
    "createdAt": "2023-12-23T09:00:00+09:00",
    "updatedAt": "2023-12-23T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Class-Validator"
    ]
  },
  "js-ts/nest-js/custom-validator": {
    "excerpt": "\n위도, 경도에 대한 범위를 넣어서 검증하는 validator를 만들어 보겠습니다.\n\n",
    "title": "Custom validation 만들기",
    "description": "",
    "createdAt": "2023-11-07T09:00:00+09:00",
    "updatedAt": "2023-11-07T09:00:00+09:00",
    "tags": [
      "NestJS"
    ]
  },
  "js-ts/nest-js/dto": {
    "excerpt": "\n## DTO란?\n\nDTO(Data Transfer Object)는 **계층간 데이터 교환**을 하기 위해 사용하는 객체로\n로직을 가지지 않은 객체이고 getter, setter 메서드만 가진 클래스를 의미합니다.\n\n![Layered 아키텍쳐](https://github.com/Zamoca42/blog/assets/96982072/9460d59f-2b48-445c-85ca-23f9b7021520)\n\n",
    "title": "DTO (Data Transfer Object)",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "NestJS"
    ]
  },
  "js-ts/nest-js/error-cli-not-found": {
    "excerpt": "\n도커를 이미지화 하거나 배포시 인스턴스에서 `sh: 1: nest: not found`를 자주 보게 되는데\n왜 이런 오류가 발생하는지 어떻게 해결했는지 포스트로 기록한다.\n\n![Render로 배포시 발생한 not found 오류](https://github.com/develop-pix/dump-in-Admin-BE/assets/96982072/bf72345c-c77e-48b3-a173-41d3a702ca19)\n\n",
    "title": "sh 1 nest not found 오류",
    "description": "",
    "createdAt": "2023-12-28T09:00:00+09:00",
    "updatedAt": "2023-12-28T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Error"
    ]
  },
  "js-ts/nest-js/error-exception": {
    "excerpt": "\nNest에는 애플리케이션 전체에서 처리되지 않은 모든 예외를 처리하는 예외 계층(Exceptions Layer)이 내장되어 있습니다.\n애플리케이션 코드에서 예외가 처리되지 않으면 이 계층에서 이를 포착한 다음 사용자에게 응답을 내보냅니다.\n\n",
    "title": "전역으로 예외 처리 적용하기",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "NestJS"
    ]
  },
  "js-ts/nest-js/exception": {
    "excerpt": "\n서비스 레이어에서 예외처리를 하고있었는데 [좋은 예외(Exception) 처리][exception-blog]에서\n글을 보고 의문이 들어 리팩터링을 진행했는데 포스트로 정리하려고한다.\n소제목 파트인 정상적인 흐름에서 Catch 금지, Layer에 맞는 예외 보고 의문이 들기 시작했다.\n\n![어디서 많이 본 로직이 보였다.](https://github.com/develop-pix/dump-in-Admin-BE/assets/96982072/ef451050-bdfe-4e59-a4c1-7030c6f181aa)\n\n",
    "title": "서비스 레이어에서 예외처리 분리하기",
    "description": "",
    "createdAt": "2024-01-03T09:00:00+09:00",
    "updatedAt": "2024-01-03T09:00:00+09:00",
    "tags": [
      "NestJS",
      "TypeORM",
      "Error"
    ]
  },
  "js-ts/nest-js/external-logger": {
    "excerpt": "\n로컬에서는 에러가 발생했을 때 터미널에서 로그메세지를 확인할 수 있지만 배포환경에서는 로그를 남겨야 어떤 문제가 발생했는지 알 수 있다.\n\n처음에는 모든 로그를 남겨서 확인하려고했으나 로그를 찾아서 확인하는 것도 번거로운 일이였다.\n그래서 예상할 수 있는 예외는 제외하고 심각한 로그를 구분해서 알림을 만드는 것이 필요했다.\n\n",
    "title": "외부 로거로 효율적으로 모니터링하기",
    "description": "",
    "createdAt": "2023-12-27T09:00:00+09:00",
    "updatedAt": "2023-12-27T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Winston",
      "Sentry"
    ]
  },
  "js-ts/nest-js/introduction": {
    "excerpt": "\n## 소개\n\nNest(NestJS)는 Node.js에 기반한 프레임워크로 Express나 Fastify를 사용하여 동작합니다\n\n#### with Express (default)\n\n```typescript\nimport * as session from \"express-session\";\n\n// somewhere in your initialization file\napp.use(\n  session({\n    secret: \"my-secret\",\n    resave: false,\n    saveUninitialized: false,\n  })\n);\n```\n\n",
    "title": "프로젝트 시작하기",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "NestJS"
    ]
  },
  "js-ts/nest-js/login-module": {
    "excerpt": "\nReact Admin에서 로그인 페이지를 만들고 Nest의 인증 모듈과 연결했을 때의 화면입니다.\n\n![로그인 화면](https://github.com/Zamoca42/blog/assets/96982072/9218fafc-bc81-4780-b22b-4274e3f3ec6b)\n\n",
    "title": "로그인 구현하기",
    "description": "",
    "createdAt": "2023-12-28T09:00:00+09:00",
    "updatedAt": "2023-12-28T09:00:00+09:00",
    "tags": [
      "NestJS"
    ]
  },
  "js-ts/nest-js/rate-limit": {
    "excerpt": "\n외부에서 로그인 시도할 때 횟수에 제약이 없다는 것은 무작위 반복해서 아이디와 비밀번호를 대입해도 막을 방법이 없다.\n이를 막을 방법에는 세션에 로그인 시도를 기록하는 방법이 있고, 일정 로그인 횟수 이상으로 시도시 ip를 차단하는 방법도 있을 것이다.\n\n",
    "title": "API 요청 시도 횟수 제한하기",
    "description": "",
    "createdAt": "2023-12-15T09:00:00+09:00",
    "updatedAt": "2023-12-15T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Express"
    ]
  },
  "js-ts/nest-js/server-monitoring": {
    "excerpt": "\n[외부 로거 도입](./external-logger.md)해서 Sentry로 error 레벨의 로그를 알림을 받도록 했었다.\nSentry의 기능 중에 크론 모니터링 기능이 있어서 NestJS가 지원하는 스케쥴러로 주기적으로 서버 상태를 모니터링하려고 했다.\n\n",
    "title": "서버 상태 모니터링하기",
    "description": "",
    "createdAt": "2023-12-30T09:00:00+09:00",
    "updatedAt": "2023-12-30T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Sentry"
    ]
  },
  "js-ts/nest-js/session": {
    "excerpt": "\nNestJS에서 [express-session][express-session]으로 세션 인증을 구현해보면서 알게된 점을 정리해보려고 합니다.\n\n",
    "title": "세션 쿠키 인증/인가",
    "description": "",
    "createdAt": "2023-11-17T09:00:00+09:00",
    "updatedAt": "2023-11-17T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Express"
    ]
  },
  "js-ts/nest-js/stack-trace": {
    "excerpt": "\n기존의 예외 처리 설정에서는 BadRequestException이 발생하면\n오류가 발생한 url이나 메세지 정도는 보여줬지만, 정확한 위치나 내용은 알 수 없었습니다.\n\n스택 트레이스를 넣어보면서 에러의 위치나 내용을 자세히 넣는 기능을 넣어보고\n내장 로거대신 winston 로거 설정을 추가해서 읽기 좋은 로거를 만들어 보려고 합니다.\n\n## 스택 트레이스란?\n\n스택 트레이스는 예외가 어디에서 발생했는지, 어떤 함수 호출 순서가 예외를 유발했는지 등을\n나타내는 정보를 로그에 추가해 디버깅 및 예외 추적 시 도움이 됩니다.\n\nNestJS에서는 Error 객체에 stack 프로퍼티를 사용해서 스택 트레이스를 볼 수 있습니다.\n\n",
    "title": "스택 트레이스로 에러 추적하기",
    "description": "",
    "createdAt": "2023-11-19T09:00:00+09:00",
    "updatedAt": "2023-11-19T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Winston"
    ]
  },
  "js-ts/nest-js/unit-test": {
    "excerpt": "",
    "title": "Stub을 이용한 단위 테스트 적용하기",
    "description": "",
    "createdAt": "2023-12-27T09:00:00+09:00",
    "updatedAt": "2023-12-27T09:00:00+09:00",
    "tags": [
      "NestJS",
      "Test"
    ]
  },
  "js-ts/deepdive/deepdive10": {
    "excerpt": "\n## 1. 객체란?\n\n자바스크립트는 객체 기반의 프로그래밍 언어이며, 원시 값을 제외한 나머지 값은 모두 객체다.\n원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체는 변경 가능한 값(mutable value)이다.\n\n객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.\n\n![10-1](https://github.com/Zamoca42/blog/assets/96982072/30727ee8-b9c9-4c6a-b5e7-a974189d3cca)\n\n프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.\n\n![10-2](https://github.com/Zamoca42/blog/assets/96982072/e9dd00c6-7cec-481e-aa6e-3a8bf9d935da)\n\n프로퍼티와 메서드의 역할은 다음과 같다\n\n- 프로퍼티: 객체의 상태를 나타내는 값(data)\n- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)\n\n이처럼 객체는 객체의 상태를 나타내는 값과 프로퍼티를 참조하고 조작할 수 있는 메서드를\n모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.\n\n![10-3](https://github.com/Zamoca42/blog/assets/96982072/59e3746c-4e49-44b9-9eb5-3a45167f4e8b)\n\n객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 객체지향 프로그래밍이라 한다.\n\n",
    "title": "10. 객체 리터럴",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive11": {
    "excerpt": "\n자바스크립트에서 값은 크게 원시 타입과 객체 타입으로 구분할 수 있다.\n\n- **원시 타입**의 값은 변경 불가능한 값이며, 변수에 할당될 때 **값에 의한 전달**로 동작한다.\n- **객체 타입**의 값은 변경 가능한 값이며, 변수에 할당될 때 **참조에 의한 전달**로 동작한다.\n\n",
    "title": "11. 원시 값과 객체의 비교",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive12": {
    "excerpt": "\n## 1. 함수란?\n\n함수는 자바스크립트에서 가장 중요한 핵심 개념이다.\n또 다른 자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다.\n\n",
    "title": "12. 함수",
    "description": "",
    "createdAt": "2023-09-29T09:00:00+09:00",
    "updatedAt": "2023-09-29T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive13": {
    "excerpt": "\n## 1. 스코프란?\n\n스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다.\n\n스코프는 변수와 함수의 유효한 범위를 나타낸다.\n\n```js\nfunction add(x, y) {\n  console.log(x, y);\n  return x + y;\n}\n\nadd(2, 5);\n\n// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.\nconsole.log(x, y); // ReferenceError\n```\n\n",
    "title": "13. 스코프",
    "description": "",
    "createdAt": "2023-09-30T09:00:00+09:00",
    "updatedAt": "2023-09-30T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive14": {
    "excerpt": "\n전역 변수의 무분별한 사용은 위험하다.\n\n전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다.\n\n이번 장에서는 전역 변수의 문제점과 전역 변수의 사용을 억제할 수 있는 방법을 살펴보자.\n\n",
    "title": "14. 전역 변수의 문제점",
    "description": "",
    "createdAt": "2023-09-30T09:00:00+09:00",
    "updatedAt": "2023-09-30T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive15": {
    "excerpt": "\n## 1. var 키워드로 선언한 변수의 문제점\n\nES5까지 변수를 선언할 수 있는 유일한 방법은 `var` 키워드를 사용하는 것이었다.  \nvar 키워드로 선언된 변수는 다음과 같은 특징이 있다.\n\n",
    "title": "15. let, const 키워드와 블록 레벨 스코프",
    "description": "",
    "createdAt": "2023-09-30T09:00:00+09:00",
    "updatedAt": "2023-09-30T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive16": {
    "excerpt": "\n## 1. 내부 슬롯과 내부 메서드\n\n내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다.\n\nECMAScript 사양에 등장하는 이중 대괄호(`[[...]]`)으로 감싼 이름들이 내부 슬롯과 내부 메서드다.\n\n",
    "title": "16. 프로퍼티 어트리뷰트",
    "description": "",
    "createdAt": "2023-10-01T09:00:00+09:00",
    "updatedAt": "2023-10-01T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive17": {
    "excerpt": "\n이번 장에서는 생성자 함수를 사용하여 객체를 생성하는 방식을 살펴보고, 객체 리터럴을 사용하여 객체를 생성하는 방식과의 장단점을 비교해보자.\n\n",
    "title": "17. 생성자 함수에 의한 객체 생성",
    "description": "",
    "createdAt": "2023-10-03T09:00:00+09:00",
    "updatedAt": "2023-10-03T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive18": {
    "excerpt": "\n## 1. 일급 객체\n\n자바스크립트의 함수는 다음 조건을 모두 만족하는 **일급 객체**다.\n\n1. 런타임에 생성이 가능하다.\n2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.\n3. 함수의 매개변수에 전달할 수 있다.\n4. 함수의 반환값으로 사용할 수 있다.\n\n",
    "title": "18. 함수와 일급 객체",
    "description": "",
    "createdAt": "2023-10-04T09:00:00+09:00",
    "updatedAt": "2023-10-04T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive19": {
    "excerpt": "\n자바스크립트는 프로토타입을 기반으로 상속을 구현하여 객체 지향 프로그래밍 능력을 지니고 있다.\n\n",
    "title": "19. 프로토타입",
    "description": "",
    "createdAt": "2023-10-05T09:00:00+09:00",
    "updatedAt": "2023-10-05T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive20": {
    "excerpt": "\n## 1. strict mode란?\n\nstrict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나\n자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.\n\n예를 들어, 선언하지 않은 변수를 참조하면 암묵적으로 전역 변수가 생성되는 현상(암묵적 전역)은 오류를 발생시키는 원인이 될 수 있다. strict mode에서는 이를 에러로 인식한다.\n\n",
    "title": "20. strict mode",
    "description": "",
    "createdAt": "2023-10-11T09:00:00+09:00",
    "updatedAt": "2023-10-11T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive21": {
    "excerpt": "",
    "title": "21. 빌트인 객체",
    "description": "",
    "createdAt": "2023-10-12T09:00:00+09:00",
    "updatedAt": "2023-10-12T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive22": {
    "excerpt": "\n## 1. this 키워드\n\n메서드에서 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 사용해야 한다.  \n이때 사용되는 것이 this 키워드다.\n\n```js\nconst circle = {\n  radius: 5,\n  getDiameter() {\n    return 2 * this.radius;\n  },\n};\n\nconsole.log(circle.getDiameter()); // 10\n```\n\n",
    "title": "22. this",
    "description": "",
    "createdAt": "2023-10-14T09:00:00+09:00",
    "updatedAt": "2023-10-14T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive23": {
    "excerpt": "",
    "title": "23. 실행 컨텍스트",
    "description": "",
    "createdAt": "2023-10-15T09:00:00+09:00",
    "updatedAt": "2023-10-15T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive24": {
    "excerpt": "",
    "title": "24. 클로저",
    "description": "",
    "createdAt": "2023-10-18T09:00:00+09:00",
    "updatedAt": "2023-10-18T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive25": {
    "excerpt": "",
    "title": "25. 클래스",
    "description": "",
    "createdAt": "2023-10-23T09:00:00+09:00",
    "updatedAt": "2023-10-23T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive26": {
    "excerpt": "",
    "title": "26. ES6 함수의 추가 기능",
    "description": "",
    "createdAt": "2023-10-29T09:00:00+09:00",
    "updatedAt": "2023-10-29T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive27": {
    "excerpt": "",
    "title": "27. 배열",
    "description": "",
    "createdAt": "2023-10-30T09:00:00+09:00",
    "updatedAt": "2023-10-30T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive34": {
    "excerpt": "",
    "title": "34. 이터러블",
    "description": "",
    "createdAt": "2023-11-09T09:00:00+09:00",
    "updatedAt": "2023-11-09T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive35": {
    "excerpt": "",
    "title": "35. 스프레드 문법",
    "description": "",
    "createdAt": "2023-11-12T09:00:00+09:00",
    "updatedAt": "2023-11-12T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive36": {
    "excerpt": "",
    "title": "36. 디스트럭처링 할당",
    "description": "",
    "createdAt": "2023-11-13T09:00:00+09:00",
    "updatedAt": "2023-11-13T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive37": {
    "excerpt": "",
    "title": "37. Set과 Map",
    "description": "",
    "createdAt": "2023-11-15T09:00:00+09:00",
    "updatedAt": "2023-11-15T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive38": {
    "excerpt": "",
    "title": "38. 브라우저의 렌더링 과정",
    "description": "",
    "createdAt": "2023-11-05T09:00:00+09:00",
    "updatedAt": "2023-11-05T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive39": {
    "excerpt": "",
    "title": "39. DOM",
    "description": "",
    "createdAt": "2023-11-05T09:00:00+09:00",
    "updatedAt": "2023-11-05T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive4": {
    "excerpt": "\n## 1. 변수란 무엇인가?\n\n- 컴퓨터는 데이터를 메모리에 저장하거나 읽어들임\n\n  - 메모리는 메모리 셀의 집합체\n\n  - 각 셀은 고유의 메모리 주소를 갖는다\n\n    - 4GB 메모리의 주소는 0x00000000 ~ 0xffffffff\n\n- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름\n\n  - 변수에 값을 저장하는 것을 **할당(대입, 저장)**\n\n  - 변수에 저장된 값을 읽어 들이는 것을 **참조**\n\n",
    "title": "4. 변수",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive40": {
    "excerpt": "\n## 1. 이벤트 드리븐 프로그래밍\n\n브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.\n예를 들어, 클릭, 키보드 입력, 마우스 이동 등이 일어나면 브라우저는 이를 감지하여 특정한 타입의 이벤트를 발생시킨다.\n\n이벤트가 발생했을 때 호출될 함수를 이벤트 핸들러라 하고,\n이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다.\n\n브라우저는 사용자 버튼 클릭을 감지하여 클릭 이벤트를 발생시킬 수 있다.\n그리고 특정 버튼 요소에서 클릭 이벤트가 발생하면 이벤트 핸들러를 호출하도록 브라우저에게 위임할 수 있다.\n\n",
    "title": "40. 이벤트",
    "description": "",
    "createdAt": "2023-11-17T09:00:00+09:00",
    "updatedAt": "2023-11-17T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive41": {
    "excerpt": "",
    "title": "41. 타이머",
    "description": "",
    "createdAt": "2023-11-20T09:00:00+09:00",
    "updatedAt": "2023-11-20T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive42": {
    "excerpt": "\n자바스크립트는 함수를 호출하면 실행 컨텍스트 스택에 푸시되고 순차적으로 함수 코드가 실행된다.\n\n![그림 42-1. 실행 컨텍스트 스택](https://github.com/Zamoca42/blog/assets/96982072/fa7ba17d-3430-4ecd-9858-118ddadd6453)\n\n자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작하기 때문에\n처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹이 발생한다.\n\n",
    "title": "42. 비동기 프로그래밍",
    "description": "",
    "createdAt": "2023-11-20T09:00:00+09:00",
    "updatedAt": "2023-11-20T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive43": {
    "excerpt": "",
    "title": "43. Ajax",
    "description": "",
    "createdAt": "2023-11-21T09:00:00+09:00",
    "updatedAt": "2023-11-21T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive45": {
    "excerpt": "",
    "title": "45. 프로미스",
    "description": "",
    "createdAt": "2023-11-22T09:00:00+09:00",
    "updatedAt": "2023-11-22T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive46": {
    "excerpt": "",
    "title": "46. 제너레이터와 async/await",
    "description": "",
    "createdAt": "2023-11-23T09:00:00+09:00",
    "updatedAt": "2023-11-23T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive47": {
    "excerpt": "",
    "title": "47. 에러처리",
    "description": "",
    "createdAt": "2023-11-25T09:00:00+09:00",
    "updatedAt": "2023-11-25T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive48": {
    "excerpt": "",
    "title": "48. 모듈",
    "description": "",
    "createdAt": "2023-11-26T09:00:00+09:00",
    "updatedAt": "2023-11-26T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive5": {
    "excerpt": "\n## 1. 값\n\n값(value)는 표현식(expression)이 평가되어 생성된 결과를 말한다.\n\n```javascript\n// 10 + 20은 평가되어 숫자 값 30을 생성\n10 + 20; // 30\n```\n\n변수는 **하나의 값**을 저장하기 위해 확보한 메모리 공간\n\n```javascript\nvar sum = 10 + 20;\n```\n\nsum변수에 할당되는 것은 10 + 20이 아니라 30이라는 값이다.\n\n",
    "title": "5. 표현식과 문",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive6": {
    "excerpt": "\n자바스크립트의 모든 값은 데이터 타입을 갖는다.\n데이터 타입(Data type)은 값의 종류를 말한다.\n\n자바스크립트(ES6)은 7개의 데이터 타입을 제공하고\n원시 타입(Primitive type)과 객체 타입(Object type)으로 분류할 수 있다.\n\n<table>\n  <tr>\n    <th>구분</th>\n    <th>데이터 타입</th>\n    <th>설명</th>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">원시 타입</td>\n    <td>숫자(number)</td>\n    <td>정수와 실수 구분 없이 하나의 숫자 타입만 존재</td>\n  </tr>\n  <tr>\n    <td>문자열(string)</td>\n    <td>문자열</td>\n  </tr>\n  <tr>\n    <td>불리언(boolean)</td>\n    <td>논리적 참(true)과 거짓(false)</td>\n  </tr>\n  <tr>\n    <td>undefined</td>\n    <td>var 키워드로 선언된 변수에 암묵적으로 할당되는 값</td>\n  </tr>\n  <tr>\n    <td>null</td>\n    <td>값이 없다는 것을 의도적으로 명시할 때 사용하는 값</td>\n  </tr>\n  <tr>\n    <td>심벌(symbol)</td>\n    <td>ES6에서 추가된 7번째 타입</td>\n  </tr>\n  <tr>\n    <td colspan=\"2\">객체 타입</td>\n    <td>객체, 함수, 배열 등</td>\n  </tr>\n</table>\n\n",
    "title": "6. 데이터 타입",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive7": {
    "excerpt": "\n연산자(Operator)는 하나 이상의 표현식을 대상으로, 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.\n\n이때 연산의 대상을 피연산자(Operand)라 한다.\n\n```javascript\n// 산술 연산자\n5 * 4; // -> 20\n\n// 문자열 연결 연산자\n\"My name is \" + \"Lee\"; // -> 'My name is Lee'\n\n// 할당 연산자\ncolor = \"red\"; // -> 'red'\n\n// 비교 연산자\n3 > 5; // -> false\n\n// 논리 연산자\ntrue && false; //-> false\n\n// 타입 연산자\ntypeof \"Hi\"; //-> string\n```\n\n연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.\n\n",
    "title": "7. 연산자",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive8": {
    "excerpt": "\n제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.\n일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.\n제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.\n\n## 1. 블록문\n\n블록문(block statement)는 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라 부르기도 한다.\n\n```javascript\n// 블록문\n{\n  var foo = 10;\n}\n\n// 제어문\nvar x = 1;\n\nif (x < 10) {\n  x++;\n}\n\n// 함수 선언문\nfunction sum(a, b) {\n  return a + b;\n}\n```\n\n",
    "title": "8. 제어문",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "js-ts/deepdive/deepdive9": {
    "excerpt": "\n## 1. 타입 변환이란?\n\n개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적(Explicit) 타입 변환**\n또는 **타입 캐스팅**이라 한다\n\n```js\nvar x = 10;\n\nvar str = x.toString();\nconsole.log(typeof str, str); // string 10\n\nconsole.log(typeof x, x); //number 10\n```\n\n개발자의 의도와는 상관 없이 표현식을 평가하는 도중에 암묵적으로 타입이 자동 변환 되기도 한다.\n\n이를 **암묵적(Implicit) 타입 변환** 또는 **타입 강제 변환**이라 한다.\n\n```js\nvar x = 10;\n\nvar str = x + \"\";\nconsole.log(typeof str, str); //string 10\n\nconsole.log(typeof x, x); //number 10\n```\n\n",
    "title": "9. 타입 변환과 단축 평가",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "JavaScript"
    ]
  },
  "etc/fastapi-nestjs-middleware": {
    "excerpt": "\n![NestJS의 요청/응답 파이프라인](/images/middleware-interceptors.jpg)\n\n현대적인 백엔드 개발에서 FastAPI와 NestJS는 높은 생산성과 확장성을 제공하는 프레임워크로 널리 사용되고 있습니다. 이 두 프레임워크에서 공통적으로 중요한 개념이 바로 **미들웨어(Middleware)** 이며, NestJS에서는 추가로 **인터셉터(Interceptor)** 개념을 제공합니다. 이 글에서는 두 프레임워크의 미들웨어 구현 방식과 NestJS의 인터셉터와 미들웨어 간의 차이점을 살펴보겠습니다.\n\n",
    "title": "미들웨어와 인터셉터",
    "description": "",
    "createdAt": "2025-04-30T09:00:00+09:00",
    "updatedAt": "2025-04-30T09:00:00+09:00",
    "tags": [
      "FastAPI",
      "NestJS",
      "Middleware",
      "Interceptor"
    ]
  },
  "etc/git-butler": {
    "excerpt": "\n> https://news.hada.io/topic?id=16281\n\n## GitButler 소개\n\nGitButler를 처음 설치하고 실행했을 때는 Source Tree와 Git Desktop, AI를 합쳐놓은 듯한 소프트웨어같은 느낌을 받았다.\n\n흔히 CLI를 통해 git 명령어를 입력하는 것과 달리 GUI로 좀 더 쉽게 버전 관리를 할 수 있도록 도와준다.\n\n직접 사용해보면서 느낀점은 AI를 통해 커밋 메시지를 자동으로 생성해주는 것이 아주 편리하다는 점이였다.\n\n",
    "title": "GitButler - 페어소스 기반의 Git 버전 관리 자동화 툴",
    "description": "",
    "createdAt": "2024-10-18T09:00:00+09:00",
    "updatedAt": "2024-10-18T09:00:00+09:00",
    "tags": [
      "Git",
      "AI",
      "Architecture",
      "Rust",
      "Svelte"
    ]
  },
  "etc/git-flow": {
    "excerpt": "\n![git flow](https://user-images.githubusercontent.com/96982072/227922966-e7f04bb8-7943-434b-8a8a-cbb4097a0339.png)\n\ngit-flow는 브랜치를 5가지 종류로 구분하여 개발하는 전략이다.\n\n",
    "title": "Git-flow",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "Git",
      "Strategy"
    ]
  },
  "etc/github-flow": {
    "excerpt": "\n![GitHub-flow](https://user-images.githubusercontent.com/96982072/227937502-73a8e6cd-1c9d-4a9f-93b0-0141d95f06c6.png)\n\n## GitHub-flow의 브랜칭 전략\n\n- 수시로 배포가 일어나며, CI와 배포가 자동화된 프로젝트\n- Release Branch가 명확하게 구분되지 않은 시스템\n- Pull Request 기능을 사용\n\n",
    "title": "GitHub-flow",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "Git",
      "Strategy"
    ]
  },
  "etc/key-binding": {
    "excerpt": "\n> https://code.visualstudio.com/docs/editor/userdefinedsnippets#_assign-keybindings-to-snippets\n\nVSCode에서는 커스텀 스니펫과 키 바인딩 기능을 제공한다.\n\n이를 활용하면 자주 사용하는 코드나 텍스트를 단축키나 단축어로 쉽게 입력할 수 있다.\n블로그 포스트를 작성 시 매번 frontmatter나 excerpt 키워드를 복사하여 붙여넣는 번거로움을 줄이기 위해 VSCode의 이 기능을 사용해 보기로 했다.\n\n",
    "title": "VSCode - 커스텀 스니펫과 키 바인딩",
    "description": "코드 스니펫을 VSCode에 단축키로 등록해 자동입력하기",
    "createdAt": "2024-06-26T09:00:00+09:00",
    "updatedAt": "2024-06-26T09:00:00+09:00",
    "tags": [
      "VSCode"
    ]
  },
  "etc/markdown-lint": {
    "excerpt": "\nMarkdownlint는 VSCode 확장 프로그램 중 하나로, 마크다운 형식의 파일을 일관성있게 작성하도록 도와주는 도구다.\n\n![https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint](https://github.com/Zamoca42/next-blog/assets/96982072/13d22865-eed5-46b1-b2bd-503f81cafa12)\n\n블로그를 작성할 때 주로 사용하고있고, VSCode 설정에서 `codeActionsOnSave` 설정 시 자동으로 규칙과 어긋난 부분을 수정한다.\n\n```diff-json:settings.json\n    //...\n    \"editor.codeActionsOnSave\": {\n        \"source.fixAll\": \"explicit\",\n+       \"source.fixAll.markdownlint\": \"explicit\"\n    },\n    //...\n```\n\n",
    "title": "Markdownlint - 마크다운 linting 도구",
    "description": "",
    "createdAt": "2024-06-20T09:00:00+09:00",
    "updatedAt": "2024-06-20T09:00:00+09:00",
    "tags": [
      "Markdown",
      "VSCode"
    ]
  },
  "etc/markdown": {
    "excerpt": "\n<!-- markdownlint-disable -->\n\n## 마크다운(Markdown)이란?\n\n마크다운(Markdown)은 텍스트 기반의 가벼운 마크업 언어 중 하나로, 읽기 쉽고 쓰기 쉬운 문법을 가지고 있다.\n\n마크다운은 HTML로 변환이 가능하며, 다양한 플랫폼과 프로그램에서 지원되고 있다.\n\n마크다운을 사용하면 **간단한 문법**으로 서식이 있는 문서를 작성할 수 있다.\n\n",
    "title": "블로그 마크다운 문법 정리",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "Markdown"
    ]
  },
  "etc/infra/grafana-prometheus-in-django": {
    "excerpt": "\n## 왜 그라파나와 프로메테우스 인가?\n\nDatadog, Sentry와 같이 여러 데이터를 시각화해서 보여주는 앱들이 많지만\n그라파나와 프로메테우스는 오픈 소스 도구로 비용이 들지 않고 다양하게 커스터마이징할 수 있다는 장점이 있었다.\n나는 프로젝트를 해오면서 모니터링 도구를 사용해본 적 없기 때문에 그라파나와 프로메테우스를 포토부스 프로젝트의 첫 모니터링 도구로 설정해보게 되었다.\n\n",
    "title": "프로메테우스 - 그라파나 in Django",
    "description": "",
    "createdAt": "2024-02-12T09:00:00+09:00",
    "updatedAt": "2024-02-12T09:00:00+09:00",
    "tags": [
      "Monitoring"
    ]
  },
  "etc/infra/node-install": {
    "excerpt": "\n프로젝트의 서버는 NestJS를 사용하고 있다.\nNestJS로 구성된 서버를 실행하려면 node와 npm이 있어야 패키지를 관리하고 실행할 수 있다.\n하지만 기본적으로 EC2 인스턴스를 만들면 Node.js와 npm 등이 설치되어 있지 않다.\n\n그래서 aws에서 ec2 인스턴스를 만들 때 기본 제공되는 unbuntu 이미지에 Node.js와 npm 설치하고\ngit clone으로 레포지토리까지 설정을 한 다음,\n초기 설정한 볼륨을 이미지(AMI)로 만들어서 자동으로 생성된 인스턴스에 초기설정이 필요없게 만들려고 한다.\n\n",
    "title": "우분투에 node & npm 설치",
    "description": "",
    "createdAt": "2024-03-05T09:00:00+09:00",
    "updatedAt": "2024-03-05T09:00:00+09:00",
    "tags": [
      "Node",
      "NPM",
      "EC2",
      "Linux"
    ]
  },
  "etc/infra/github-actions/ci-cd": {
    "excerpt": "\n> CI/CD 개념 부분은 참고 링크의 레드햇 기술블로그와 요즘 IT의 CI/CD 개념과 깃허브 리포지터리 생성하기 부분의 개념 부분을 참조했습니다.\n\nCI/CD (Continuous Integration/Continuous Delivery)는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는\n통합 지옥(integration hell)을 자동화하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법입니다.\nCI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포입니다.\n\n",
    "title": "CI/CD란?",
    "description": "",
    "createdAt": "2024-02-12T09:00:00+09:00",
    "updatedAt": "2024-02-12T09:00:00+09:00",
    "tags": [
      "CI",
      "CD"
    ]
  },
  "etc/infra/github-actions/ec2-deploy": {
    "excerpt": "\n이번 글에서는 GitHub Actions에서 AWS CodeDeploy에 전달하고 EC2에 Django 서버를 배포하는 것까지 진행해보겠습니다.\n\n",
    "title": "EC2에 Django 서버 배포하기",
    "description": "",
    "createdAt": "2024-02-12T09:00:00+09:00",
    "updatedAt": "2024-02-12T09:00:00+09:00",
    "tags": [
      "CD"
    ]
  },
  "etc/infra/github-actions/github-actions": {
    "excerpt": "\n> https://docs.github.com/ko/actions - GitHub Actions 공식 문서\n\nGithub Actions에 대해 간단히 설명하면 테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼입니다.\n레포지토리에서 push같은 이벤트가 일어날 때, workflow를 통해 작업이 실행되는 자동화 프로세스로 각 작업은 자체 가상머신을 사용하여 실행됩니다.\n\n이번에는 GitHub Actions를 사용해서 AWS EC2에는 서버를 배포하고 S3에는 정적 웹페이지에 배포를 자동화 해보겠습니다.\n\n",
    "title": "GitHub Actions",
    "description": "",
    "createdAt": "2024-02-12T09:00:00+09:00",
    "updatedAt": "2024-02-12T09:00:00+09:00",
    "tags": [
      "CI",
      "CD"
    ]
  },
  "etc/infra/github-actions/s3-deploy": {
    "excerpt": "\nAWS S3 버킷에 vue로 빌드한 페이지를 정적 웹 사이트로 호스팅할 수 있습니다.\n\n- [Amazon S3를 사용하여 정적 웹 사이트 호스팅](https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/WebsiteHosting.html?icmpid=docs_amazons3_console)\n\nS3 버킷을 정적 웹사이트로 호스팅하기 위해서는 다음과 같은 설정이 필요합니다.\n\n1. 퍼블릭 액세스 설정\n2. 버킷 정책 설정\n3. CORS 설정\n\n이렇게 버킷을 설정하는 방법을 알아보고 GitHub Actions에서 배포 설정을 자동화 해보겠습니다.\n\n",
    "title": "S3에 정적 웹페이지 배포하기",
    "description": "",
    "createdAt": "2024-02-12T09:00:00+09:00",
    "updatedAt": "2024-02-12T09:00:00+09:00",
    "tags": [
      "CD"
    ]
  },
  "etc/infra/docker/dev-container": {
    "excerpt": "\n## DevContainer란 무엇인가?\n\n> [VS Code로 컨테이너 안에서 개발하기](https://ssowonny.medium.com/vs-code%EB%A1%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%95%88%EC%97%90%EC%84%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-d8ed0950d69a)\n>\n> [Developing inside a Container - vscode 문서](https://code.visualstudio.com/docs/devcontainers/containers)\n\nDevContainer는 주로 Visual Studio Code와 같은 통합 개발 환경(IDE)에서 사용되며,\nVisual Studio Code의 확장 앱을 통해 구성할 수 있습니다.\n이를 통해 프로젝트를 개발하는 동안 개발 환경을 컨테이너 내에서 실행하고 호스트 시스템과 분리시키는 것이 가능합니다.\n\n",
    "title": "DevContainer - VSCode(IDE)에서 리눅스 환경으로 개발하고 디버깅하기",
    "description": "",
    "createdAt": "2024-02-12T09:00:00+09:00",
    "updatedAt": "2024-02-12T09:00:00+09:00",
    "tags": [
      "Docker",
      "Debug"
    ]
  },
  "etc/git/cheat-sheet": {
    "excerpt": "\n## 설정\n\n**vscode로 git 설정**\n\n```shell\ngit config --global core.editor \"code --wait\"\n```\n\n",
    "title": "자주 사용하는 git 명령어 모음",
    "description": "",
    "createdAt": "2024-04-03T09:00:00+09:00",
    "updatedAt": "2024-04-03T09:00:00+09:00",
    "tags": [
      "Git"
    ]
  },
  "etc/git/git-sparse-checkout": {
    "excerpt": "\n현재 프로젝트 레포지토리의 디렉터리 구조는 이렇게 되어있다.\n\n> :file_folder: toeic  \n> ├─ :file_folder: backend/  \n> ├─ :file_folder: frontend/  \n> ├─ package-lock.json  \n> └─ package.json\n\nGitHub 레포지토리에서 frontend 디렉터리를 제외한 나머지 파일 및 디렉터리를 clone해서 가져오려면 어떻게 해야할까?\n\n",
    "title": "필요한 디렉터리만 clone하기",
    "description": "",
    "createdAt": "2024-03-05T09:00:00+09:00",
    "updatedAt": "2024-03-05T09:00:00+09:00",
    "tags": [
      "Git"
    ]
  },
  "etc/git/merge": {
    "excerpt": "\ngit에서 브랜치와 다른 브랜치를 합치는 명령어가 `merge`\n\n## merge 명령어\n\n브랜치와 다른 브랜치를 합치기 위해서 최종으로 합치고싶은 브랜치로 이동\n\n예를 들어, `post`라는 브랜치와 `main`이라는 브랜치가 존재\n\n`main`에 `post`를 합치고 싶다면 `main` 브랜치로 이동\n\n",
    "title": "merge",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "Git"
    ]
  },
  "etc/db/dynamoose": {
    "excerpt": "\nNest에서는 TypeORM, Prisma, Mongoose 등 다양한 ORM을 사용할 수 있기 때문에\nSQL이나 NoSQL 데이터베이스 모두 쉽게 연결할 수 있습니다.\n\n이번 주제에서는 AWS의 대표적인 NoSQL 기반 데이터베이스인 DynamoDB를 Dynamoose를 이용해서 연결해보겠습니다.\n\n",
    "title": "DynamoDB 연결하기 with NestJS",
    "description": "",
    "createdAt": "2023-12-28T09:00:00+09:00",
    "updatedAt": "2023-12-28T09:00:00+09:00",
    "tags": [
      "NestJS",
      "DynamoDB",
      "Dynamoose"
    ]
  },
  "etc/db/prisma-instance": {
    "excerpt": "\nNext.js에서 Prisma를 사용하여 로컬 개발 환경에서 작업하다 보면, 터미널에 다음과 같은 경고 메시지가 나타나는 경우가 있다.\n\n```txt\nwarn(prisma-client) There are already 10 instances of Prisma Client actively running.\n```\n\n이 글에서는 이 경고 메시지가 발생하는 이유와 해결 방법에 대해 알아보려고 한다.\n\n",
    "title": "Prisma - 인스턴스 경고 해결하기",
    "description": "",
    "createdAt": "2024-05-23T09:00:00+09:00",
    "updatedAt": "2024-05-23T09:00:00+09:00",
    "tags": [
      "Prisma",
      "MySQL",
      "PlanetScale"
    ]
  },
  "etc/db/prisma-relation-mode": {
    "excerpt": "\n이번에는 MySQL 로컬환경에서 PlanetScale 서비스로 넘어가기 위한 설정을 할 때 겪었던 에러에 대해 다루려고 한다.\n\n![VT10001 외래키 제약 에러 발생](https://github.com/Zamoca42/blog/assets/96982072/e0429b8d-12e9-45c8-9625-6d22189d91c1)\n\n",
    "title": "Prisma - relationMode 에러",
    "description": "",
    "createdAt": "2024-05-22T09:00:00+09:00",
    "updatedAt": "2024-05-22T09:00:00+09:00",
    "tags": [
      "Prisma",
      "MySQL",
      "PlanetScale"
    ]
  },
  "etc/db/query-range": {
    "excerpt": "\n공공데이터로 맛집 목록을 받아와서 지도에 내 위치 주변 맛집을 보여주는 API를 만들었습니다.\n\n> 해당 프로젝트 링크: https://github.com/pre-onboarding-backend-G/feed-me-baby\n\n제가 맡은 부분은 전처리된 데이터를 가져와서 맛집 목록을 지도에 표시할 수 있게 반환하는 부분입니다.\n\n여러 방법이 있겠지만 처음에는 맛집 목록을 내 위치 기준으로 범위만큼 위도나 경도를 빼거나 더해서 가져왔습니다.\n\n",
    "title": "맛집 목록 가져와서 지도에 표시하기",
    "description": "",
    "createdAt": "2023-12-28T09:00:00+09:00",
    "updatedAt": "2023-12-28T09:00:00+09:00",
    "tags": [
      "NestJS",
      "PostgreSQL",
      "TypeORM"
    ]
  },
  "etc/db/typeorm-distinct": {
    "excerpt": "\nTypeORM을 사용해서 개발하다보면 페이지네이션 처리를 해야하는 경우가 생긴다.\n이 때 목록 조회 API를 구현하고 요청할 때 SQL문을 보면 SELECT 쿼리에 DISTINCT가 들어있는 경우가 있다.\n\n![유저 목록 조회시 DISTINCT 쿼리가 생기는 것을 볼 수 있다.](https://github.com/Zamoca42/blog/assets/96982072/f109a7a3-0fe3-43da-9d7b-5cc149e79553)\n\nSELECT DISTINCT 쿼리는 왜 생기는지 궁금하여 찾아보다가 나온 정보들을 이번 포스트에서 정리하려고한다.\n\n",
    "title": "TypeORM - DISTINCT",
    "description": "",
    "createdAt": "2024-01-26T09:00:00+09:00",
    "updatedAt": "2024-01-26T09:00:00+09:00",
    "tags": [
      "Database",
      "TypeORM",
      "ORM",
      "NestJS"
    ]
  },
  "etc/db/sql/sql-subquery": {
    "excerpt": "\n> https://youtu.be/lwmwlA2WhFc?si=Szgl3bDlly7CF266\n\n서브쿼리(subquery)란 nested query 또는 inner query 라고 불리며\nSELECT, INSERT, UPDATE, DELETE 쿼리문에 포함된 쿼리를 말한다.\n\n",
    "title": "SQL - subquery",
    "description": "",
    "createdAt": "2024-02-09T09:00:00+09:00",
    "updatedAt": "2024-02-09T09:00:00+09:00",
    "tags": [
      "SQL"
    ]
  },
  "etc/db/sql/sql": {
    "excerpt": "\n> SQL 첫걸음 1 ~ 5강의 내용입니다\n\n## 데이터 베이스를 조작하는 언어 SQL\n\n- SQL은 '관계형 데이터베이스 관리 시스템(RDBMS)'을 조작할 때 사용한다.\n\n- 관계형 데이터베이스\n  - Oracle\n  - DB2\n  - SQL Server\n  - PostgreSQL\n  - MySQL\n  - SQLite\n\n",
    "title": "(SQL 첫걸음) 1 ~ 5강",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "SQL"
    ]
  },
  "etc/db/sql/sql2": {
    "excerpt": "\n> SQL 첫걸음 6 ~ 10강의 내용입니다\n\n## 검색 조건 지정하기\n\n데이터를 검색하는 방법에는 열을 지정하는 방법과 행을 지정하는 방법이 있습니다.\n\n```sql\nSELECT 열1, 열2 FROM 테이블명 WHERE 조건식\n```\n\n",
    "title": "(SQL 첫걸음) 6 ~ 10강",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "SQL"
    ]
  },
  "etc/db/sql/sql3": {
    "excerpt": "\n> SQL 첫걸음 11 ~ 15강의 내용입니다\n\n## 결과 행 제한하기\n\nLIMIT 구로 결과 행을 제한하는 방법에 관해 알아보겠습니다.\n\n```sql\nSELECT 열명 FROM 테이블명 LIMIT 행수 [OFFSET 시작행]\n```\n\n",
    "title": "(SQL 첫걸음) 11 ~ 15강",
    "description": "",
    "createdAt": "2023-10-16T09:00:00+09:00",
    "updatedAt": "2023-10-16T09:00:00+09:00",
    "tags": [
      "SQL"
    ]
  },
  "etc/coding-test/boj-2748": {
    "excerpt": "\n피보나치 수를 구할 때 동적계획법을 활용 해보겠습니다.\n\n피보나치 수는 0과 1로 시작합니다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다.\n그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 됩니다.\n\n이를 점화식으로 나타내면 $F_n = F_{n-1} + F_{n-2}$ 이고 $n = 17$ 일 때 까지 피보나치 수를 써보면 다음과 같습니다.\n\n",
    "title": "백준 2748 - 피보나치 수",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "Codingtest",
      "Boj"
    ]
  },
  "etc/coding-test/programmers-mbti": {
    "excerpt": "\n프로그래머스 [성격 유형 검사하기][personal] 문제입니다.\n\n문제에서 각 지표는 4개 지표로 나눠집니다.\n\n1. 라이언형(R), 튜브형(T)\n2. 콘형(C), 프로도형(F)\n3. 제이지형(J), 무지형(M)\n4. 어피치형(A), 네오형(N)\n\n예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다.\n\n|   선택지    |            성격 유형 점수             |\n| :---------: | :-----------------------------------: |\n| 매우 비동의 |              네오형 3점               |\n|   비동의    |              네오형 2점               |\n| 약간 비동의 |              네오형 1점               |\n|  모르겠음   | 어떤 성격 유형도 점수를 얻지 않습니다 |\n|  약간 동의  |             어피치형 1점              |\n|    동의     |             어피치형 2점              |\n|  매우 동의  |             어피치형 3점              |\n\n",
    "title": "성격유형 검사하기 - Python",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "Codingtest",
      "Programmers"
    ]
  },
  "etc/coding-test/programmers-report": {
    "excerpt": "\n프로그래머스 [신고 결과 받기][report] 문제입니다\n\n",
    "title": "신고 결과 받기 - Python",
    "description": "",
    "createdAt": "2023-09-28T09:00:00+09:00",
    "updatedAt": "2023-09-28T09:00:00+09:00",
    "tags": [
      "Codingtest",
      "Programmers"
    ]
  }
}