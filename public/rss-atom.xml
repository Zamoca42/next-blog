<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zamoca.space</id>
    <title>Zamoca Space</title>
    <updated>2025-02-02T14:19:11.312Z</updated>
    <generator>generate-rss</generator>
    <author>
        <name>추연규(Zamoca)</name>
        <email>yk@choo.ooo</email>
        <uri>https://zamoca.space</uri>
    </author>
    <link rel="alternate" href="https://zamoca.space"/>
    <link rel="self" href="https://zamoca.space/atom"/>
    <subtitle>A statically generated blog using Next.js and Markdown.</subtitle>
    <logo>https://zamoca.space/android-chrome-512x512.png</logo>
    <icon>https://zamoca.space/favicon.ico</icon>
    <rights>All rights reserved since 2024, 추연규(Zamoca)</rights>
    <entry>
        <title type="html"><![CDATA[블로그 이전 후기]]></title>
        <id>retrospect/blog-migrate</id>
        <link href="https://zamoca.space/retrospect/blog-migrate"/>
        <updated>2023-10-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
처음 vue-django를 이용해서 기술 블로그를 사용하면서 옵시디언으로 글을 작성해서 블로그에 업로드하고
GitHub의 TIL 리포지토리에 쓴 글들을 백업하는 과정이 있었는데 업로드 과정이 비효율적이라는 생각이 들었습니다.
점점 공부한 내용을 기록하고 업로드하는 과정이 즐겁지 않아서 업로드 기간이 늘어나고 점점 글을 쓰지 않게 되었습니다.
그래서 업로드 기간이 늘어난 것에 대해 고민을 하다가 vue-django 블로그를 정리하고 GitHub Pages로 블로그를 변경했습니다.
블로그를 바꾸게된 과정과 생각을 이번 글에서 정리해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그로 이전 후기]]></title>
        <id>retrospect/next-blog-migrate</id>
        <link href="https://zamoca.space/retrospect/next-blog-migrate"/>
        <updated>2024-07-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Vuepress에서 Next.js로 블로그를 이전한 후기입니다.]]></summary>
        <content type="html"><![CDATA[
Vuepress를 이용한 블로그를 사용하다가 여러 가지 문제에 부딪히게 되었다.
처음에는 블로그에 최적화된 레이아웃과 마크다운을 사용하는 것이 편했으나,
의존성 충돌이 빈번하게 일어나고 제한적인 플러그인과 트러블 슈팅에 대한 정보가 부족해 한계를 느껴 Next.js로 변경을 고려하게 되었다.

이번 포스트에서는 Next.js로 블로그를 이전하기까지 과정을 정리하고 공유해보려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[오후스튜디오 회원 관리 페이지 개발 후기]]></title>
        <id>retrospect/ohoo-admin</id>
        <link href="https://zamoca.space/retrospect/ohoo-admin"/>
        <updated>2023-10-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
오후스튜디오에서 일하시는 개발자분과 멘토링하면서 실제 DB테이블을 가지고 회원 관리 페이지를 만들어보자고
제안해주셔서 회원 정보, 요금제 정보를 불러오는 페이지를 만들어봤습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[내가 오픈소스에 기여하게된 이유와 2025년 목표]]></title>
        <id>retrospect/oss-contribution</id>
        <link href="https://zamoca.space/retrospect/oss-contribution"/>
        <updated>2025-02-02T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Open-Source"/>
        <category label="Career"/>
        <category label="Growth"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 파일 미리보기 기여 후기]]></title>
        <id>retrospect/oss-gitbutler-binary</id>
        <link href="https://zamoca.space/retrospect/oss-gitbutler-binary"/>
        <updated>2024-10-21T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 관련 이슈 1: https://github.com/gitbutlerapp/gitbutler/issues/2752  
> 관련 이슈 2: https://github.com/gitbutlerapp/gitbutler/issues/3093

이번 후기는 GitButler에서 바이너리 파일(이미지, 폰트파일 등)을 미리보기 기능을 구현한 것에 대한 후기이다.

![UI에서 미리보기 없이 Binary content not shown을 출력한다](https://github.com/user-attachments/assets/bc6269bd-14c0-4874-afc5-526d8ca82dfa)

관련 이슈를 살펴보면 바이너리 파일을 미리보기 기능을 구현하는 것에 대한 이슈가 있었다.  
UI에서 이미지는 미리보기 기능, 이미지 외의 파일에 대한 사이즈 정보를 보여주는 기능을 구현하는 것이 목표였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="GitButler"/>
        <category label="Git"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 리눅스 환경에서 실행시 창이 꺼지는 문제 기여 후기]]></title>
        <id>retrospect/oss-gitbutler-linux-window</id>
        <link href="https://zamoca.space/retrospect/oss-gitbutler-linux-window"/>
        <updated>2024-10-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 해당 이슈: https://github.com/gitbutlerapp/gitbutler/issues/4039

GitButler를 살펴보다 발견한 이슈는 리눅스 환경에서 최대화를 시도하면 창이 자동으로 꺼지는 문제였다.

링크에서 이슈를 살펴보면 Tauri의 window-state와 관련이 있는거 같긴 했지만 Tauri와 의존된 부분이 많아서 정확히 부분을 찾아야했다.

helpwanted 라벨이 달려있어서 해당 이슈에 기여해보고 싶어졌다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="GitButler"/>
        <category label="Linux"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tauri - 리눅스 환경에서 실행시 창이 꺼지는 문제 기여 후기 2]]></title>
        <id>retrospect/oss-tauri-tao</id>
        <link href="https://zamoca.space/retrospect/oss-tauri-tao"/>
        <updated>2024-10-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> [이전 포스트](https://zamoca.space/etc/retrospect/oss-gitbutler-linux-window)에서 이어지는 내용입니다.  
> 해당 이슈: https://github.com/tauri-apps/tao/issues/977

처음에는 linux에서 `Error 71 (Protocol error) dispatching to Wayland display.`가 발생하는 이유는
Tauri의 window-state 플러그인의 자체적인 문제라고 생각했다.

그래서 Tauri의 플러그인 레포지토리에 [이슈](https://github.com/tauri-apps/plugins-workspace/issues/1779)를 남겼지만
창이 최대화시에 발생하는 문제라면 Tauri의 업스트림 중 하나인 Tao에서 발생하는 문제라고 답변을 들을 수 있었다.

![타우리의 아키텍쳐](https://github.com/user-attachments/assets/cc83e09a-0ad6-4da6-9e25-bd812079a2ec)

Tao는 Tauri에서 창을 생성하고 관리하는 라이브러리이다.

그래서 이슈를 Tao에서 다시 작성한 후에 Discord에 메인테이너에게 기여를 해도되는지 문의를 했고
메인테이너에게 자유롭게 기여를 해도된다는 답변을 받았다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Tauri"/>
        <category label="Linux"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-django 블로그 개발 후기]]></title>
        <id>retrospect/vue-django-blog</id>
        <link href="https://zamoca.space/retrospect/vue-django-blog"/>
        <updated>2023-10-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
로봇공학, 인공지능 강의를 들으면서 파이썬에 관심을 가지게 되었고 파이썬으로 공부를 하면서 배운 것을 어떻게 적용해볼 수 있을지 고민했습니다.
마침 인프런에서 vue-django 블로그 만들기가 눈에 들어왔고 만들어서 기술블로그로 사용할 생각으로 AWS에 배포까지 계획했습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Auth.js로 알아보는 세션과 JWT 인증 방식의 차이]]></title>
        <id>js-ts/auth-js</id>
        <link href="https://zamoca.space/js-ts/auth-js"/>
        <updated>2024-08-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Auth.js를 활용하여 개발하면서 세션(Session)과 JWT(JSON Web Token) 인증 방식에 대해 실제로 경험해 볼 수 있었다.
두 방식 모두 쿠키를 사용하기에 각 방식의 특징과 사용 경험을 중심으로 정리해 보았다.

## Auth.js 소개

> 🌐 https://authjs.dev/getting-started

Auth.js는 인증을 쉽게 구현할 수 있게 해주는 강력한 라이브러리다.  
Google 로그인과 같은 OAuth나 이메일 인증 로그인을 지원하며, 세션 및 JWT 기반의 인증을 모두 구현할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JWT"/>
        <category label="Session"/>
        <category label="Next.js"/>
        <category label="Auth.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[date-fns로 Date 객체 다루기]]></title>
        <id>js-ts/date-fns</id>
        <link href="https://zamoca.space/js-ts/date-fns"/>
        <updated>2024-04-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
TODO 앱을 직접 만들어보면서 오늘 날짜를 기준으로 완료 여부를 확인할 수 있는 기능을 만들어보기 위해

date-fns 라이브러리를 사용했다.

## startOfDay, endOfDay

date-fns의 startOfDay와 endOfDay 함수를 사용하면 Date 객체 기준

날짜의 시작 시간과 완료 시간을 보여주는데

오늘의 범위를 0시부터 23시 59분 기준으로 생각하고 함수를 사용하면 생각과 다른 결과가 나온다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="TypeScript"/>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js로 디렉토리 트리 탐색하기]]></title>
        <id>js-ts/node-readdir</id>
        <link href="https://zamoca.space/js-ts/node-readdir"/>
        <updated>2024-06-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[fs.readdir의 recursive 옵션으로 모든 마크다운 파일 찾기]]></summary>
        <content type="html"><![CDATA[
Next.js 블로그 스타터를 시작하면 마크다운 포스트를 가져오는 로직은 `fs.readFileSync()`를 사용하여 컨텐츠 폴더 아래의 파일만 탐색하게 된다.

```ts:lib/api.ts {15}
import { Post } from "@/interfaces/post";
import fs from "fs";
import matter from "gray-matter";
import { join } from "path";

const postsDirectory = join(process.cwd(), "_posts");

export function getPostSlugs() {
  return fs.readdirSync(postsDirectory);
}

export function getPostBySlug(slug: string) {
  const realSlug = slug.replace(/\.md$/, "");
  const fullPath = join(postsDirectory, `${realSlug}.md`);
  const fileContents = fs.readFileSync(fullPath, "utf8");
  const { data, content } = matter(fileContents);

  return { ...data, slug: realSlug, content } as Post;
}
//...
```

하지만 컨텐츠 폴더 내부에 하위 폴더가 존재하면 해당 폴더 내의 파일은 찾지 못하는 문제가 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node.js"/>
        <category label="TypeScript"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[사이드바 정렬 개선하기]]></title>
        <id>js-ts/sidebar-sorting</id>
        <link href="https://zamoca.space/js-ts/sidebar-sorting"/>
        <updated>2024-06-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[폴더, 파일을 문자열 정렬에서 개선해보자]]></summary>
        <content type="html"><![CDATA[
블로그의 사이드바에서 현재 포스트가 가지고 있는 카테고리 폴더와 파일을 보여주려고 컴포넌트를 만들었는데,
정렬 방식이 마음에 들지 않았다.

이를 개선하기 위해 두 가지 목표를 설정했다.

1. 숫자를 포함한 정렬 방식으로 변경
2. 폴더를 파일보다 상위에 배치

![자바스크립트 문자열 방식으로 정렬하고 폴더와 파일의 순서에 구분이 없었다.](https://github.com/Zamoca42/next-blog/assets/96982072/3743a624-545c-48c5-b341-342a722d8a97)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node.js"/>
        <category label="TypeScript"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그에 검색 적용하기 - Docsearch]]></title>
        <id>js-ts/next/blog-docsearch</id>
        <link href="https://zamoca.space/js-ts/next/blog-docsearch"/>
        <updated>2024-07-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
블로그에 검색 기능이 없어서 한글 형태소 지원, 적은 비용, 쉬운 유지보수를 고려한 라이브러리 사용을 고민하다 Typesense와 Aloglia를 알게 되었다.

Algolia는 Vuepress나 공식문서 페이지에서 자주 볼 수 있었는데,
한글 형태소 검색이 지원되고 프리티어로 한달에 요청횟수 10k, 지원 문서 수 100만개까지 적용되어서 사용해봤다.

이번 포스트에서는 Next.js에서 문서 검색을 설정한 과정에서 겪은 일들을 정리하려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Aloglia"/>
        <category label="Next.js"/>
        <category label="TypeScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 14 - HotReload 에러]]></title>
        <id>js-ts/next/hot-reload</id>
        <link href="https://zamoca.space/js-ts/next/hot-reload"/>
        <updated>2024-06-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
NextJS로 프로젝트를 진행하던 중에 [Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)
를 설정해 모달창을 구현하다가 HotReload 에러를 만나게 되었다.

![내가 겪은 에러와 완전히 같아서 참고링크의 사진을 첨부했다.](https://github.com/Zamoca42/blog/assets/96982072/9df58ab8-0822-4079-8e18-072df747b9fd)

Next로 모달을 구현하게되면 Parallel Routes를 자주 사용하게 될텐데 같은 에러가 생기면 다시 해결하기 위해 기록으로 남겨두려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="TypeScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 14 - Lighthouse로 웹페이지 성능 개선하기]]></title>
        <id>js-ts/next/lighthouse</id>
        <link href="https://zamoca.space/js-ts/next/lighthouse"/>
        <updated>2024-07-31T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Next.js 14 정적 블로그에서 성능 개선을 시도한 경험을 이번 포스트에서 정리하려고 한다.
처음에는 웹 성능 측정 도구에 대해 잘 몰라 어떤 지표로 성능을 평가해야 할지 막막했다.

## Lighthouse 도구 발견

![초기 성능 진단 결과](https://github.com/user-attachments/assets/dbea020e-29f7-4ff0-9ccb-d1b175dd4716)

웹 성능 최적화에 대해 검색하던 중 Google에서 제공하는 Lighthouse라는 도구를 알게 되었다.
Lighthouse는 웹페이지의 성능, 접근성, SEO 등 다양한 측면을 분석해주는 강력한 도구였다.

![초기 진단 항목들 중 LCP와 FCP에 영향을 주는 항목이 눈에 띈다.](https://github.com/user-attachments/assets/2bdd2c27-9fe1-448b-a16f-346680ecf0a7)

프로덕션 환경에서 실행 결과, Largest Contentful Paint(LCP)이 눈에 띄는데  
진단 항목을 살펴보면 이미지가 주된 원인이였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Lighthouse"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[마크다운 플러그인 세팅]]></title>
        <id>js-ts/next/markdown-plugin</id>
        <link href="https://zamoca.space/js-ts/next/markdown-plugin"/>
        <updated>2024-07-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[마크다운 플러그인인 remark, rehype와 react-markdown에 대해 알아보자]]></summary>
        <content type="html"><![CDATA[
정적 블로그를 만들 때 마크다운 파일을 사용하는 경우, 단순히 `<div>` 태그와 `dangerouslySetInnerHTML` 속성으로 정적 콘텐츠를 삽입할 수 있다.

하지만 이 방법으로는 추가적인 커스터마이징이 어렵다.

이를 해결하기 위해 `next-mdx-remote`와 같은 라이브러리와 `remark` 같은 플러그인을 사용하면 HTML 코드를 원하는 대로 수정할 수 있다.

Next.js 공식 문서에서는 MDX를 이용한 정적 블로그 예시를 제공하고 있다.
하지만 이미 마크다운 형식으로 포스트를 작성해왔기 때문에 MDX로 변환할 필요성을 느끼지 못했다. `next-mdx-remote`에서 옵션으로 `.md` format을 지원하지만
설정하는 방법이 직관적이라는 생각이 들지 않아서 [react-markdown](https://github.com/remarkjs/react-markdown)
을 사용하기로 결정했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="React"/>
        <category label="Markdown"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Auth.js v4 - Unknown arg `access_token`... 에러]]></title>
        <id>js-ts/next/prisma-token-schema-error</id>
        <link href="https://zamoca.space/js-ts/next/prisma-token-schema-error"/>
        <updated>2024-06-13T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Auth.js는 NextJS 친화적으로 설계된 오픈소스 인증 라이브러리다.

NextJS에서 간단한 설정만으로 OAuth나 이메일 인증 로직을 적용할 수 있어 편리하다.

다만 커스터마이징을 하기에는 사용자가 내부로직을 알기 모호하고 문서가 복잡하고 불친절하다는 느낌을 받았다.

그 예로 NextJS에서 Prisma를 이용해 구글 이메일 로그인을 구현하면서 겪은 에러에 대해 정리하려고 한다.

해당 내용은 Auth.js v4에서 겪은 에러로 내용은 다음과 같다.

```txt:에러내용
Unknown arg `access_token` in data.access_token for type AccountUncheckedCreateInput. Did you mean `accessToken`?
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Auth.js"/>
        <category label="Prisma"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js - 빌드 타임에 스크립트를 실행하는 방법]]></title>
        <id>js-ts/next/run-script-build-time</id>
        <link href="https://zamoca.space/js-ts/next/run-script-build-time"/>
        <updated>2024-06-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What's the recommended way to run a script at build time?]]></summary>
        <content type="html"><![CDATA[
마크다운 컨텐츠를 활용한 블로그를 만들면서 포스트의 생성일과 수정일을 커밋 날짜를 기준으로 블로그에 보여주려고 했다.

git 명령어를 [node.js의 child_process](https://www.freecodecamp.org/korean/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/)
로 실행하면서 개발서버에서는 이상없이 돌아갔으나...

Vercel에 배포 할때는 `.git` 레포지토리가 포함되지 않기 때문에 git 명령어를 사용할 수 없다고 한다.

![vercel command failed](https://github.com/Zamoca42/blog/assets/96982072/4cdbfb40-d459-424a-966b-4794e5b13f90)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Node"/>
        <category label="Script"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js - SEO와 검색엔진 등록]]></title>
        <id>js-ts/next/seo</id>
        <link href="https://zamoca.space/js-ts/next/seo"/>
        <updated>2024-07-24T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
구글과 네이버 같은 검색엔진은 크롤링 봇이 있는데 크롤링 봇이 웹사이트와 웹페이지를 수집하고 등록시켜 검색하는 유저에게 노출한다.
SEO(Search Engine Optimization)는 검색엔진 크롤링 봇에게 내 웹페이지를 수집하기 쉽도록 개선하는 작업을 말한다.  
SEO를 직접 제공하는 블로그 서비스를 이용하는 것이 아닌 이상 자동으로 검색엔진에 등록되는일은 없으므로 SEO를 위한 작업이 필요하다.

Next.js 14버전의 App router를 기준으로 진행한 SEO 작업들을 정리하려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SEO"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[고객정보 API 만들기]]></title>
        <id>js-ts/nest-js/api</id>
        <link href="https://zamoca.space/js-ts/nest-js/api"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![회원 정보 검색](https://github.com/Zamoca42/blog/assets/96982072/3cb4e5b5-b460-470e-8c80-f65a1502ed44)

이렇게 클라이언트에서 회원아이디를 입력했을때 회원의 정보를 보여주려고합니다

```json
{
  "id": "sdfsdf333",
  "phoneNumber": "+821099990001",
  "email": "이메일@.com",
  "businessName": "회사이름",
  "businessItem": "사업"
}
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Project"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[응답 객체 직렬화하기]]></title>
        <id>js-ts/nest-js/class-transformer</id>
        <link href="https://zamoca.space/js-ts/nest-js/class-transformer"/>
        <updated>2023-12-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
요청 객체를 역직렬화 과정과 마찬가지로 클라이언트에 데이터를 전달할 때
응답 객체를 인스턴스로 변환하는데 NestJS에서는 `class-transformer`를 사용한다.

한 객체가 변경이 발생하면 해당 객체에 의존하는 다른 객체들도 변경해야 하기 때문에 이들의 변경 범위를 최소화 하기 위해 캡슐화를 사용한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Class-Transformer"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[요청 객체 역직렬화하기]]></title>
        <id>js-ts/nest-js/class-validator</id>
        <link href="https://zamoca.space/js-ts/nest-js/class-validator"/>
        <updated>2023-12-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
클라이언트에서 HTTP 요청시 JSON이나 쿼리스트링의 경우 클래스 인스턴스로 변환하는 역직렬화와 유효성 검사과정이 필요하다.

이 부분은 `class-validator` 패키지가 필요하다.
[`class-validator`][class-validator]는 데코레이터를 기반으로 Dto들의 검증을 담당한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Class-Validator"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Custom validation 만들기]]></title>
        <id>js-ts/nest-js/custom-validator</id>
        <link href="https://zamoca.space/js-ts/nest-js/custom-validator"/>
        <updated>2023-11-07T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
위도, 경도에 대한 범위를 넣어서 검증하는 validator를 만들어 보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DTO (Data Transfer Object)]]></title>
        <id>js-ts/nest-js/dto</id>
        <link href="https://zamoca.space/js-ts/nest-js/dto"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## DTO란?

DTO(Data Transfer Object)는 **계층간 데이터 교환**을 하기 위해 사용하는 객체로
로직을 가지지 않은 객체이고 getter, setter 메서드만 가진 클래스를 의미합니다.

![Layered 아키텍쳐](https://github.com/Zamoca42/blog/assets/96982072/9460d59f-2b48-445c-85ca-23f9b7021520)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[sh 1 nest not found 오류]]></title>
        <id>js-ts/nest-js/error-cli-not-found</id>
        <link href="https://zamoca.space/js-ts/nest-js/error-cli-not-found"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
도커를 이미지화 하거나 배포시 인스턴스에서 `sh: 1: nest: not found`를 자주 보게 되는데
왜 이런 오류가 발생하는지 어떻게 해결했는지 포스트로 기록한다.

![Render로 배포시 발생한 not found 오류](https://github.com/develop-pix/dump-in-Admin-BE/assets/96982072/bf72345c-c77e-48b3-a173-41d3a702ca19)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Error"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[전역으로 예외 처리 적용하기]]></title>
        <id>js-ts/nest-js/error-exception</id>
        <link href="https://zamoca.space/js-ts/nest-js/error-exception"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Nest에는 애플리케이션 전체에서 처리되지 않은 모든 예외를 처리하는 예외 계층(Exceptions Layer)이 내장되어 있습니다.
애플리케이션 코드에서 예외가 처리되지 않으면 이 계층에서 이를 포착한 다음 사용자에게 응답을 내보냅니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[서비스 레이어에서 예외처리 분리하기]]></title>
        <id>js-ts/nest-js/exception</id>
        <link href="https://zamoca.space/js-ts/nest-js/exception"/>
        <updated>2024-01-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
서비스 레이어에서 예외처리를 하고있었는데 [좋은 예외(Exception) 처리][exception-blog]에서
글을 보고 의문이 들어 리팩터링을 진행했는데 포스트로 정리하려고한다.
소제목 파트인 정상적인 흐름에서 Catch 금지, Layer에 맞는 예외 보고 의문이 들기 시작했다.

![어디서 많이 본 로직이 보였다.](https://github.com/develop-pix/dump-in-Admin-BE/assets/96982072/ef451050-bdfe-4e59-a4c1-7030c6f181aa)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="TypeORM"/>
        <category label="Error"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[외부 로거로 효율적으로 모니터링하기]]></title>
        <id>js-ts/nest-js/external-logger</id>
        <link href="https://zamoca.space/js-ts/nest-js/external-logger"/>
        <updated>2023-12-27T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
로컬에서는 에러가 발생했을 때 터미널에서 로그메세지를 확인할 수 있지만 배포환경에서는 로그를 남겨야 어떤 문제가 발생했는지 알 수 있다.

처음에는 모든 로그를 남겨서 확인하려고했으나 로그를 찾아서 확인하는 것도 번거로운 일이였다.
그래서 예상할 수 있는 예외는 제외하고 심각한 로그를 구분해서 알림을 만드는 것이 필요했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Winston"/>
        <category label="Sentry"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[프로젝트 시작하기]]></title>
        <id>js-ts/nest-js/introduction</id>
        <link href="https://zamoca.space/js-ts/nest-js/introduction"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 소개

Nest(NestJS)는 Node.js에 기반한 프레임워크로 Express나 Fastify를 사용하여 동작합니다

#### with Express (default)

```typescript
import * as session from "express-session";

// somewhere in your initialization file
app.use(
  session({
    secret: "my-secret",
    resave: false,
    saveUninitialized: false,
  })
);
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[로그인 구현하기]]></title>
        <id>js-ts/nest-js/login-module</id>
        <link href="https://zamoca.space/js-ts/nest-js/login-module"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
React Admin에서 로그인 페이지를 만들고 Nest의 인증 모듈과 연결했을 때의 화면입니다.

![로그인 화면](https://github.com/Zamoca42/blog/assets/96982072/9218fafc-bc81-4780-b22b-4274e3f3ec6b)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[API 요청 시도 횟수 제한하기]]></title>
        <id>js-ts/nest-js/rate-limit</id>
        <link href="https://zamoca.space/js-ts/nest-js/rate-limit"/>
        <updated>2023-12-15T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
외부에서 로그인 시도할 때 횟수에 제약이 없다는 것은 무작위 반복해서 아이디와 비밀번호를 대입해도 막을 방법이 없다.
이를 막을 방법에는 세션에 로그인 시도를 기록하는 방법이 있고, 일정 로그인 횟수 이상으로 시도시 ip를 차단하는 방법도 있을 것이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Express"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[서버 상태 모니터링하기]]></title>
        <id>js-ts/nest-js/server-monitoring</id>
        <link href="https://zamoca.space/js-ts/nest-js/server-monitoring"/>
        <updated>2023-12-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
[외부 로거 도입](./external-logger.md)해서 Sentry로 error 레벨의 로그를 알림을 받도록 했었다.
Sentry의 기능 중에 크론 모니터링 기능이 있어서 NestJS가 지원하는 스케쥴러로 주기적으로 서버 상태를 모니터링하려고 했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Sentry"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[세션 쿠키 인증/인가]]></title>
        <id>js-ts/nest-js/session</id>
        <link href="https://zamoca.space/js-ts/nest-js/session"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
NestJS에서 [express-session][express-session]으로 세션 인증을 구현해보면서 알게된 점을 정리해보려고 합니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Express"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[스택 트레이스로 에러 추적하기]]></title>
        <id>js-ts/nest-js/stack-trace</id>
        <link href="https://zamoca.space/js-ts/nest-js/stack-trace"/>
        <updated>2023-11-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
기존의 예외 처리 설정에서는 BadRequestException이 발생하면
오류가 발생한 url이나 메세지 정도는 보여줬지만, 정확한 위치나 내용은 알 수 없었습니다.

스택 트레이스를 넣어보면서 에러의 위치나 내용을 자세히 넣는 기능을 넣어보고
내장 로거대신 winston 로거 설정을 추가해서 읽기 좋은 로거를 만들어 보려고 합니다.

## 스택 트레이스란?

스택 트레이스는 예외가 어디에서 발생했는지, 어떤 함수 호출 순서가 예외를 유발했는지 등을
나타내는 정보를 로그에 추가해 디버깅 및 예외 추적 시 도움이 됩니다.

NestJS에서는 Error 객체에 stack 프로퍼티를 사용해서 스택 트레이스를 볼 수 있습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Winston"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stub을 이용한 단위 테스트 적용하기]]></title>
        <id>js-ts/nest-js/unit-test</id>
        <link href="https://zamoca.space/js-ts/nest-js/unit-test"/>
        <updated>2023-12-27T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Test"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[10. 객체 리터럴]]></title>
        <id>js-ts/deepdive/deepdive10</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive10"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 객체란?

자바스크립트는 객체 기반의 프로그래밍 언어이며, 원시 값을 제외한 나머지 값은 모두 객체다.
원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체는 변경 가능한 값(mutable value)이다.

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.

![10-1](https://github.com/Zamoca42/blog/assets/96982072/30727ee8-b9c9-4c6a-b5e7-a974189d3cca)

프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.

![10-2](https://github.com/Zamoca42/blog/assets/96982072/e9dd00c6-7cec-481e-aa6e-3a8bf9d935da)

프로퍼티와 메서드의 역할은 다음과 같다

- 프로퍼티: 객체의 상태를 나타내는 값(data)
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

이처럼 객체는 객체의 상태를 나타내는 값과 프로퍼티를 참조하고 조작할 수 있는 메서드를
모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.

![10-3](https://github.com/Zamoca42/blog/assets/96982072/59e3746c-4e49-44b9-9eb5-3a45167f4e8b)

객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 객체지향 프로그래밍이라 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[11. 원시 값과 객체의 비교]]></title>
        <id>js-ts/deepdive/deepdive11</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive11"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트에서 값은 크게 원시 타입과 객체 타입으로 구분할 수 있다.

- **원시 타입**의 값은 변경 불가능한 값이며, 변수에 할당될 때 **값에 의한 전달**로 동작한다.
- **객체 타입**의 값은 변경 가능한 값이며, 변수에 할당될 때 **참조에 의한 전달**로 동작한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[12. 함수]]></title>
        <id>js-ts/deepdive/deepdive12</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive12"/>
        <updated>2023-09-29T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 함수란?

함수는 자바스크립트에서 가장 중요한 핵심 개념이다.
또 다른 자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[13. 스코프]]></title>
        <id>js-ts/deepdive/deepdive13</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive13"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 스코프란?

스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다.

스코프는 변수와 함수의 유효한 범위를 나타낸다.

```js
function add(x, y) {
  console.log(x, y);
  return x + y;
}

add(2, 5);

// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x, y); // ReferenceError
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[14. 전역 변수의 문제점]]></title>
        <id>js-ts/deepdive/deepdive14</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive14"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
전역 변수의 무분별한 사용은 위험하다.

전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다.

이번 장에서는 전역 변수의 문제점과 전역 변수의 사용을 억제할 수 있는 방법을 살펴보자.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[15. let, const 키워드와 블록 레벨 스코프]]></title>
        <id>js-ts/deepdive/deepdive15</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive15"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. var 키워드로 선언한 변수의 문제점

ES5까지 변수를 선언할 수 있는 유일한 방법은 `var` 키워드를 사용하는 것이었다.  
var 키워드로 선언된 변수는 다음과 같은 특징이 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[16. 프로퍼티 어트리뷰트]]></title>
        <id>js-ts/deepdive/deepdive16</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive16"/>
        <updated>2023-10-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 내부 슬롯과 내부 메서드

내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다.

ECMAScript 사양에 등장하는 이중 대괄호(`[[...]]`)으로 감싼 이름들이 내부 슬롯과 내부 메서드다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[17. 생성자 함수에 의한 객체 생성]]></title>
        <id>js-ts/deepdive/deepdive17</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive17"/>
        <updated>2023-10-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번 장에서는 생성자 함수를 사용하여 객체를 생성하는 방식을 살펴보고, 객체 리터럴을 사용하여 객체를 생성하는 방식과의 장단점을 비교해보자.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[18. 함수와 일급 객체]]></title>
        <id>js-ts/deepdive/deepdive18</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive18"/>
        <updated>2023-10-04T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 일급 객체

자바스크립트의 함수는 다음 조건을 모두 만족하는 **일급 객체**다.

1. 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[19. 프로토타입]]></title>
        <id>js-ts/deepdive/deepdive19</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive19"/>
        <updated>2023-10-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트는 프로토타입을 기반으로 상속을 구현하여 객체 지향 프로그래밍 능력을 지니고 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[20. strict mode]]></title>
        <id>js-ts/deepdive/deepdive20</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive20"/>
        <updated>2023-10-11T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. strict mode란?

strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나
자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

예를 들어, 선언하지 않은 변수를 참조하면 암묵적으로 전역 변수가 생성되는 현상(암묵적 전역)은 오류를 발생시키는 원인이 될 수 있다. strict mode에서는 이를 에러로 인식한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[21. 빌트인 객체]]></title>
        <id>js-ts/deepdive/deepdive21</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive21"/>
        <updated>2023-10-12T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[22. this]]></title>
        <id>js-ts/deepdive/deepdive22</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive22"/>
        <updated>2023-10-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. this 키워드

메서드에서 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 사용해야 한다.  
이때 사용되는 것이 this 키워드다.

```js
const circle = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  },
};

console.log(circle.getDiameter()); // 10
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[23. 실행 컨텍스트]]></title>
        <id>js-ts/deepdive/deepdive23</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive23"/>
        <updated>2023-10-15T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[24. 클로저]]></title>
        <id>js-ts/deepdive/deepdive24</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive24"/>
        <updated>2023-10-18T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[25. 클래스]]></title>
        <id>js-ts/deepdive/deepdive25</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive25"/>
        <updated>2023-10-23T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[26. ES6 함수의 추가 기능]]></title>
        <id>js-ts/deepdive/deepdive26</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive26"/>
        <updated>2023-10-29T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[27. 배열]]></title>
        <id>js-ts/deepdive/deepdive27</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive27"/>
        <updated>2023-10-30T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[34. 이터러블]]></title>
        <id>js-ts/deepdive/deepdive34</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive34"/>
        <updated>2023-11-09T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[35. 스프레드 문법]]></title>
        <id>js-ts/deepdive/deepdive35</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive35"/>
        <updated>2023-11-12T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[36. 디스트럭처링 할당]]></title>
        <id>js-ts/deepdive/deepdive36</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive36"/>
        <updated>2023-11-13T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[37. Set과 Map]]></title>
        <id>js-ts/deepdive/deepdive37</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive37"/>
        <updated>2023-11-15T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[38. 브라우저의 렌더링 과정]]></title>
        <id>js-ts/deepdive/deepdive38</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive38"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[39. DOM]]></title>
        <id>js-ts/deepdive/deepdive39</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive39"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[4. 변수]]></title>
        <id>js-ts/deepdive/deepdive4</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive4"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 변수란 무엇인가?

- 컴퓨터는 데이터를 메모리에 저장하거나 읽어들임

  - 메모리는 메모리 셀의 집합체

  - 각 셀은 고유의 메모리 주소를 갖는다

    - 4GB 메모리의 주소는 0x00000000 ~ 0xffffffff

- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름

  - 변수에 값을 저장하는 것을 **할당(대입, 저장)**

  - 변수에 저장된 값을 읽어 들이는 것을 **참조**

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[40. 이벤트]]></title>
        <id>js-ts/deepdive/deepdive40</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive40"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 이벤트 드리븐 프로그래밍

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.
예를 들어, 클릭, 키보드 입력, 마우스 이동 등이 일어나면 브라우저는 이를 감지하여 특정한 타입의 이벤트를 발생시킨다.

이벤트가 발생했을 때 호출될 함수를 이벤트 핸들러라 하고,
이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다.

브라우저는 사용자 버튼 클릭을 감지하여 클릭 이벤트를 발생시킬 수 있다.
그리고 특정 버튼 요소에서 클릭 이벤트가 발생하면 이벤트 핸들러를 호출하도록 브라우저에게 위임할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[41. 타이머]]></title>
        <id>js-ts/deepdive/deepdive41</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive41"/>
        <updated>2023-11-20T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[42. 비동기 프로그래밍]]></title>
        <id>js-ts/deepdive/deepdive42</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive42"/>
        <updated>2023-11-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트는 함수를 호출하면 실행 컨텍스트 스택에 푸시되고 순차적으로 함수 코드가 실행된다.

![그림 42-1. 실행 컨텍스트 스택](https://github.com/Zamoca42/blog/assets/96982072/fa7ba17d-3430-4ecd-9858-118ddadd6453)

자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작하기 때문에
처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹이 발생한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[43. Ajax]]></title>
        <id>js-ts/deepdive/deepdive43</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive43"/>
        <updated>2023-11-21T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[45. 프로미스]]></title>
        <id>js-ts/deepdive/deepdive45</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive45"/>
        <updated>2023-11-22T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[46. 제너레이터와 async/await]]></title>
        <id>js-ts/deepdive/deepdive46</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive46"/>
        <updated>2023-11-23T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[47. 에러처리]]></title>
        <id>js-ts/deepdive/deepdive47</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive47"/>
        <updated>2023-11-25T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[48. 모듈]]></title>
        <id>js-ts/deepdive/deepdive48</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive48"/>
        <updated>2023-11-26T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[5. 표현식과 문]]></title>
        <id>js-ts/deepdive/deepdive5</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive5"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 값

값(value)는 표현식(expression)이 평가되어 생성된 결과를 말한다.

```javascript
// 10 + 20은 평가되어 숫자 값 30을 생성
10 + 20; // 30
```

변수는 **하나의 값**을 저장하기 위해 확보한 메모리 공간

```javascript
var sum = 10 + 20;
```

sum변수에 할당되는 것은 10 + 20이 아니라 30이라는 값이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[6. 데이터 타입]]></title>
        <id>js-ts/deepdive/deepdive6</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive6"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트의 모든 값은 데이터 타입을 갖는다.
데이터 타입(Data type)은 값의 종류를 말한다.

자바스크립트(ES6)은 7개의 데이터 타입을 제공하고
원시 타입(Primitive type)과 객체 타입(Object type)으로 분류할 수 있다.

<table>
  <tr>
    <th>구분</th>
    <th>데이터 타입</th>
    <th>설명</th>
  </tr>
  <tr>
    <td rowspan="6">원시 타입</td>
    <td>숫자(number)</td>
    <td>정수와 실수 구분 없이 하나의 숫자 타입만 존재</td>
  </tr>
  <tr>
    <td>문자열(string)</td>
    <td>문자열</td>
  </tr>
  <tr>
    <td>불리언(boolean)</td>
    <td>논리적 참(true)과 거짓(false)</td>
  </tr>
  <tr>
    <td>undefined</td>
    <td>var 키워드로 선언된 변수에 암묵적으로 할당되는 값</td>
  </tr>
  <tr>
    <td>null</td>
    <td>값이 없다는 것을 의도적으로 명시할 때 사용하는 값</td>
  </tr>
  <tr>
    <td>심벌(symbol)</td>
    <td>ES6에서 추가된 7번째 타입</td>
  </tr>
  <tr>
    <td colspan="2">객체 타입</td>
    <td>객체, 함수, 배열 등</td>
  </tr>
</table>

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. 연산자]]></title>
        <id>js-ts/deepdive/deepdive7</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive7"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
연산자(Operator)는 하나 이상의 표현식을 대상으로, 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

이때 연산의 대상을 피연산자(Operand)라 한다.

```javascript
// 산술 연산자
5 * 4; // -> 20

// 문자열 연결 연산자
"My name is " + "Lee"; // -> 'My name is Lee'

// 할당 연산자
color = "red"; // -> 'red'

// 비교 연산자
3 > 5; // -> false

// 논리 연산자
true && false; //-> false

// 타입 연산자
typeof "Hi"; //-> string
```

연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. 제어문]]></title>
        <id>js-ts/deepdive/deepdive8</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive8"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.
일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.
제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.

## 1. 블록문

블록문(block statement)는 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라 부르기도 한다.

```javascript
// 블록문
{
  var foo = 10;
}

// 제어문
var x = 1;

if (x < 10) {
  x++;
}

// 함수 선언문
function sum(a, b) {
  return a + b;
}
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[9. 타입 변환과 단축 평가]]></title>
        <id>js-ts/deepdive/deepdive9</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive9"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 타입 변환이란?

개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적(Explicit) 타입 변환**
또는 **타입 캐스팅**이라 한다

```js
var x = 10;

var str = x.toString();
console.log(typeof str, str); // string 10

console.log(typeof x, x); //number 10
```

개발자의 의도와는 상관 없이 표현식을 평가하는 도중에 암묵적으로 타입이 자동 변환 되기도 한다.

이를 **암묵적(Implicit) 타입 변환** 또는 **타입 강제 변환**이라 한다.

```js
var x = 10;

var str = x + "";
console.log(typeof str, str); //string 10

console.log(typeof x, x); //number 10
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 페어소스 기반의 Git 버전 관리 자동화 툴]]></title>
        <id>etc/git-butler</id>
        <link href="https://zamoca.space/etc/git-butler"/>
        <updated>2024-10-18T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://news.hada.io/topic?id=16281

## GitButler 소개

GitButler를 처음 설치하고 실행했을 때는 Source Tree와 Git Desktop, AI를 합쳐놓은 듯한 소프트웨어같은 느낌을 받았다.

흔히 CLI를 통해 git 명령어를 입력하는 것과 달리 GUI로 좀 더 쉽게 버전 관리를 할 수 있도록 도와준다.

직접 사용해보면서 느낀점은 AI를 통해 커밋 메시지를 자동으로 생성해주는 것이 아주 편리하다는 점이였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="AI"/>
        <category label="Architecture"/>
        <category label="Rust"/>
        <category label="Svelte"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git-flow]]></title>
        <id>etc/git-flow</id>
        <link href="https://zamoca.space/etc/git-flow"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![git flow](https://user-images.githubusercontent.com/96982072/227922966-e7f04bb8-7943-434b-8a8a-cbb4097a0339.png)

git-flow는 브랜치를 5가지 종류로 구분하여 개발하는 전략이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="Strategy"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub-flow]]></title>
        <id>etc/github-flow</id>
        <link href="https://zamoca.space/etc/github-flow"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![GitHub-flow](https://user-images.githubusercontent.com/96982072/227937502-73a8e6cd-1c9d-4a9f-93b0-0141d95f06c6.png)

## GitHub-flow의 브랜칭 전략

- 수시로 배포가 일어나며, CI와 배포가 자동화된 프로젝트
- Release Branch가 명확하게 구분되지 않은 시스템
- Pull Request 기능을 사용

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="Strategy"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[VSCode - 커스텀 스니펫과 키 바인딩]]></title>
        <id>etc/key-binding</id>
        <link href="https://zamoca.space/etc/key-binding"/>
        <updated>2024-06-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[코드 스니펫을 VSCode에 단축키로 등록해 자동입력하기]]></summary>
        <content type="html"><![CDATA[
> https://code.visualstudio.com/docs/editor/userdefinedsnippets#_assign-keybindings-to-snippets

VSCode에서는 커스텀 스니펫과 키 바인딩 기능을 제공한다.

이를 활용하면 자주 사용하는 코드나 텍스트를 단축키나 단축어로 쉽게 입력할 수 있다.
블로그 포스트를 작성 시 매번 frontmatter나 excerpt 키워드를 복사하여 붙여넣는 번거로움을 줄이기 위해 VSCode의 이 기능을 사용해 보기로 했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="VSCode"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdownlint - 마크다운 linting 도구]]></title>
        <id>etc/markdown-lint</id>
        <link href="https://zamoca.space/etc/markdown-lint"/>
        <updated>2024-06-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Markdownlint는 VSCode 확장 프로그램 중 하나로, 마크다운 형식의 파일을 일관성있게 작성하도록 도와주는 도구다.

![https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint](https://github.com/Zamoca42/next-blog/assets/96982072/13d22865-eed5-46b1-b2bd-503f81cafa12)

블로그를 작성할 때 주로 사용하고있고, VSCode 설정에서 `codeActionsOnSave` 설정 시 자동으로 규칙과 어긋난 부분을 수정한다.

```diff-json:settings.json
    //...
    "editor.codeActionsOnSave": {
        "source.fixAll": "explicit",
+       "source.fixAll.markdownlint": "explicit"
    },
    //...
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Markdown"/>
        <category label="VSCode"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그 마크다운 문법 정리]]></title>
        <id>etc/markdown</id>
        <link href="https://zamoca.space/etc/markdown"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
<!-- markdownlint-disable -->

## 마크다운(Markdown)이란?

마크다운(Markdown)은 텍스트 기반의 가벼운 마크업 언어 중 하나로, 읽기 쉽고 쓰기 쉬운 문법을 가지고 있다.

마크다운은 HTML로 변환이 가능하며, 다양한 플랫폼과 프로그램에서 지원되고 있다.

마크다운을 사용하면 **간단한 문법**으로 서식이 있는 문서를 작성할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Markdown"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[프로메테우스 - 그라파나 in Django]]></title>
        <id>etc/infra/grafana-prometheus-in-django</id>
        <link href="https://zamoca.space/etc/infra/grafana-prometheus-in-django"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 왜 그라파나와 프로메테우스 인가?

Datadog, Sentry와 같이 여러 데이터를 시각화해서 보여주는 앱들이 많지만
그라파나와 프로메테우스는 오픈 소스 도구로 비용이 들지 않고 다양하게 커스터마이징할 수 있다는 장점이 있었다.
나는 프로젝트를 해오면서 모니터링 도구를 사용해본 적 없기 때문에 그라파나와 프로메테우스를 포토부스 프로젝트의 첫 모니터링 도구로 설정해보게 되었다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Monitoring"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[우분투에 node & npm 설치]]></title>
        <id>etc/infra/node-install</id>
        <link href="https://zamoca.space/etc/infra/node-install"/>
        <updated>2024-03-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로젝트의 서버는 NestJS를 사용하고 있다.
NestJS로 구성된 서버를 실행하려면 node와 npm이 있어야 패키지를 관리하고 실행할 수 있다.
하지만 기본적으로 EC2 인스턴스를 만들면 Node.js와 npm 등이 설치되어 있지 않다.

그래서 aws에서 ec2 인스턴스를 만들 때 기본 제공되는 unbuntu 이미지에 Node.js와 npm 설치하고
git clone으로 레포지토리까지 설정을 한 다음,
초기 설정한 볼륨을 이미지(AMI)로 만들어서 자동으로 생성된 인스턴스에 초기설정이 필요없게 만들려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node"/>
        <category label="NPM"/>
        <category label="EC2"/>
        <category label="Linux"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[CI/CD란?]]></title>
        <id>etc/infra/github-actions/ci-cd</id>
        <link href="https://zamoca.space/etc/infra/github-actions/ci-cd"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> CI/CD 개념 부분은 참고 링크의 레드햇 기술블로그와 요즘 IT의 CI/CD 개념과 깃허브 리포지터리 생성하기 부분의 개념 부분을 참조했습니다.

CI/CD (Continuous Integration/Continuous Delivery)는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는
통합 지옥(integration hell)을 자동화하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법입니다.
CI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포입니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CI"/>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[EC2에 Django 서버 배포하기]]></title>
        <id>etc/infra/github-actions/ec2-deploy</id>
        <link href="https://zamoca.space/etc/infra/github-actions/ec2-deploy"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번 글에서는 GitHub Actions에서 AWS CodeDeploy에 전달하고 EC2에 Django 서버를 배포하는 것까지 진행해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Actions]]></title>
        <id>etc/infra/github-actions/github-actions</id>
        <link href="https://zamoca.space/etc/infra/github-actions/github-actions"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://docs.github.com/ko/actions - GitHub Actions 공식 문서

Github Actions에 대해 간단히 설명하면 테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼입니다.
레포지토리에서 push같은 이벤트가 일어날 때, workflow를 통해 작업이 실행되는 자동화 프로세스로 각 작업은 자체 가상머신을 사용하여 실행됩니다.

이번에는 GitHub Actions를 사용해서 AWS EC2에는 서버를 배포하고 S3에는 정적 웹페이지에 배포를 자동화 해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CI"/>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[S3에 정적 웹페이지 배포하기]]></title>
        <id>etc/infra/github-actions/s3-deploy</id>
        <link href="https://zamoca.space/etc/infra/github-actions/s3-deploy"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
AWS S3 버킷에 vue로 빌드한 페이지를 정적 웹 사이트로 호스팅할 수 있습니다.

- [Amazon S3를 사용하여 정적 웹 사이트 호스팅](https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/WebsiteHosting.html?icmpid=docs_amazons3_console)

S3 버킷을 정적 웹사이트로 호스팅하기 위해서는 다음과 같은 설정이 필요합니다.

1. 퍼블릭 액세스 설정
2. 버킷 정책 설정
3. CORS 설정

이렇게 버킷을 설정하는 방법을 알아보고 GitHub Actions에서 배포 설정을 자동화 해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DevContainer - VSCode(IDE)에서 리눅스 환경으로 개발하고 디버깅하기]]></title>
        <id>etc/infra/docker/dev-container</id>
        <link href="https://zamoca.space/etc/infra/docker/dev-container"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## DevContainer란 무엇인가?

> [VS Code로 컨테이너 안에서 개발하기](https://ssowonny.medium.com/vs-code%EB%A1%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%95%88%EC%97%90%EC%84%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-d8ed0950d69a)
>
> [Developing inside a Container - vscode 문서](https://code.visualstudio.com/docs/devcontainers/containers)

DevContainer는 주로 Visual Studio Code와 같은 통합 개발 환경(IDE)에서 사용되며,
Visual Studio Code의 확장 앱을 통해 구성할 수 있습니다.
이를 통해 프로젝트를 개발하는 동안 개발 환경을 컨테이너 내에서 실행하고 호스트 시스템과 분리시키는 것이 가능합니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Docker"/>
        <category label="Debug"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[자주 사용하는 git 명령어 모음]]></title>
        <id>etc/git/cheat-sheet</id>
        <link href="https://zamoca.space/etc/git/cheat-sheet"/>
        <updated>2024-04-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 설정

**vscode로 git 설정**

```shell
git config --global core.editor "code --wait"
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[필요한 디렉터리만 clone하기]]></title>
        <id>etc/git/git-sparse-checkout</id>
        <link href="https://zamoca.space/etc/git/git-sparse-checkout"/>
        <updated>2024-03-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
현재 프로젝트 레포지토리의 디렉터리 구조는 이렇게 되어있다.

> :file_folder: toeic  
> ├─ :file_folder: backend/  
> ├─ :file_folder: frontend/  
> ├─ package-lock.json  
> └─ package.json

GitHub 레포지토리에서 frontend 디렉터리를 제외한 나머지 파일 및 디렉터리를 clone해서 가져오려면 어떻게 해야할까?

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[merge]]></title>
        <id>etc/git/merge</id>
        <link href="https://zamoca.space/etc/git/merge"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
git에서 브랜치와 다른 브랜치를 합치는 명령어가 `merge`

## merge 명령어

브랜치와 다른 브랜치를 합치기 위해서 최종으로 합치고싶은 브랜치로 이동

예를 들어, `post`라는 브랜치와 `main`이라는 브랜치가 존재

`main`에 `post`를 합치고 싶다면 `main` 브랜치로 이동

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DynamoDB 연결하기 with NestJS]]></title>
        <id>etc/db/dynamoose</id>
        <link href="https://zamoca.space/etc/db/dynamoose"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Nest에서는 TypeORM, Prisma, Mongoose 등 다양한 ORM을 사용할 수 있기 때문에
SQL이나 NoSQL 데이터베이스 모두 쉽게 연결할 수 있습니다.

이번 주제에서는 AWS의 대표적인 NoSQL 기반 데이터베이스인 DynamoDB를 Dynamoose를 이용해서 연결해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="DynamoDB"/>
        <category label="Dynamoose"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma - 인스턴스 경고 해결하기]]></title>
        <id>etc/db/prisma-instance</id>
        <link href="https://zamoca.space/etc/db/prisma-instance"/>
        <updated>2024-05-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Next.js에서 Prisma를 사용하여 로컬 개발 환경에서 작업하다 보면, 터미널에 다음과 같은 경고 메시지가 나타나는 경우가 있다.

```txt
warn(prisma-client) There are already 10 instances of Prisma Client actively running.
```

이 글에서는 이 경고 메시지가 발생하는 이유와 해결 방법에 대해 알아보려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Prisma"/>
        <category label="MySQL"/>
        <category label="PlanetScale"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma - relationMode 에러]]></title>
        <id>etc/db/prisma-relation-mode</id>
        <link href="https://zamoca.space/etc/db/prisma-relation-mode"/>
        <updated>2024-05-22T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번에는 MySQL 로컬환경에서 PlanetScale 서비스로 넘어가기 위한 설정을 할 때 겪었던 에러에 대해 다루려고 한다.

![VT10001 외래키 제약 에러 발생](https://github.com/Zamoca42/blog/assets/96982072/e0429b8d-12e9-45c8-9625-6d22189d91c1)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Prisma"/>
        <category label="MySQL"/>
        <category label="PlanetScale"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[맛집 목록 가져와서 지도에 표시하기]]></title>
        <id>etc/db/query-range</id>
        <link href="https://zamoca.space/etc/db/query-range"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
공공데이터로 맛집 목록을 받아와서 지도에 내 위치 주변 맛집을 보여주는 API를 만들었습니다.

> 해당 프로젝트 링크: https://github.com/pre-onboarding-backend-G/feed-me-baby

제가 맡은 부분은 전처리된 데이터를 가져와서 맛집 목록을 지도에 표시할 수 있게 반환하는 부분입니다.

여러 방법이 있겠지만 처음에는 맛집 목록을 내 위치 기준으로 범위만큼 위도나 경도를 빼거나 더해서 가져왔습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="PostgreSQL"/>
        <category label="TypeORM"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeORM - DISTINCT]]></title>
        <id>etc/db/typeorm-distinct</id>
        <link href="https://zamoca.space/etc/db/typeorm-distinct"/>
        <updated>2024-01-26T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
TypeORM을 사용해서 개발하다보면 페이지네이션 처리를 해야하는 경우가 생긴다.
이 때 목록 조회 API를 구현하고 요청할 때 SQL문을 보면 SELECT 쿼리에 DISTINCT가 들어있는 경우가 있다.

![유저 목록 조회시 DISTINCT 쿼리가 생기는 것을 볼 수 있다.](https://github.com/Zamoca42/blog/assets/96982072/f109a7a3-0fe3-43da-9d7b-5cc149e79553)

SELECT DISTINCT 쿼리는 왜 생기는지 궁금하여 찾아보다가 나온 정보들을 이번 포스트에서 정리하려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Database"/>
        <category label="TypeORM"/>
        <category label="ORM"/>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL - subquery]]></title>
        <id>etc/db/sql/sql-subquery</id>
        <link href="https://zamoca.space/etc/db/sql/sql-subquery"/>
        <updated>2024-02-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://youtu.be/lwmwlA2WhFc?si=Szgl3bDlly7CF266

서브쿼리(subquery)란 nested query 또는 inner query 라고 불리며
SELECT, INSERT, UPDATE, DELETE 쿼리문에 포함된 쿼리를 말한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 1 ~ 5강]]></title>
        <id>etc/db/sql/sql</id>
        <link href="https://zamoca.space/etc/db/sql/sql"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 1 ~ 5강의 내용입니다

## 데이터 베이스를 조작하는 언어 SQL

- SQL은 '관계형 데이터베이스 관리 시스템(RDBMS)'을 조작할 때 사용한다.

- 관계형 데이터베이스
  - Oracle
  - DB2
  - SQL Server
  - PostgreSQL
  - MySQL
  - SQLite

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 6 ~ 10강]]></title>
        <id>etc/db/sql/sql2</id>
        <link href="https://zamoca.space/etc/db/sql/sql2"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 6 ~ 10강의 내용입니다

## 검색 조건 지정하기

데이터를 검색하는 방법에는 열을 지정하는 방법과 행을 지정하는 방법이 있습니다.

```sql
SELECT 열1, 열2 FROM 테이블명 WHERE 조건식
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 11 ~ 15강]]></title>
        <id>etc/db/sql/sql3</id>
        <link href="https://zamoca.space/etc/db/sql/sql3"/>
        <updated>2023-10-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 11 ~ 15강의 내용입니다

## 결과 행 제한하기

LIMIT 구로 결과 행을 제한하는 방법에 관해 알아보겠습니다.

```sql
SELECT 열명 FROM 테이블명 LIMIT 행수 [OFFSET 시작행]
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[백준 2748 - 피보나치 수]]></title>
        <id>etc/coding-test/boj-2748</id>
        <link href="https://zamoca.space/etc/coding-test/boj-2748"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
피보나치 수를 구할 때 동적계획법을 활용 해보겠습니다.

피보나치 수는 0과 1로 시작합니다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다.
그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 됩니다.

이를 점화식으로 나타내면 $F_n = F_{n-1} + F_{n-2}$ 이고 $n = 17$ 일 때 까지 피보나치 수를 써보면 다음과 같습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Boj"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[성격유형 검사하기 - Python]]></title>
        <id>etc/coding-test/programmers-mbti</id>
        <link href="https://zamoca.space/etc/coding-test/programmers-mbti"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로그래머스 [성격 유형 검사하기][personal] 문제입니다.

문제에서 각 지표는 4개 지표로 나눠집니다.

1. 라이언형(R), 튜브형(T)
2. 콘형(C), 프로도형(F)
3. 제이지형(J), 무지형(M)
4. 어피치형(A), 네오형(N)

예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다.

|   선택지    |            성격 유형 점수             |
| :---------: | :-----------------------------------: |
| 매우 비동의 |              네오형 3점               |
|   비동의    |              네오형 2점               |
| 약간 비동의 |              네오형 1점               |
|  모르겠음   | 어떤 성격 유형도 점수를 얻지 않습니다 |
|  약간 동의  |             어피치형 1점              |
|    동의     |             어피치형 2점              |
|  매우 동의  |             어피치형 3점              |

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Programmers"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[신고 결과 받기 - Python]]></title>
        <id>etc/coding-test/programmers-report</id>
        <link href="https://zamoca.space/etc/coding-test/programmers-report"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로그래머스 [신고 결과 받기][report] 문제입니다

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Programmers"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그 이전 후기]]></title>
        <id>retrospect/blog-migrate</id>
        <link href="https://zamoca.space/retrospect/blog-migrate"/>
        <updated>2023-10-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
처음 vue-django를 이용해서 기술 블로그를 사용하면서 옵시디언으로 글을 작성해서 블로그에 업로드하고
GitHub의 TIL 리포지토리에 쓴 글들을 백업하는 과정이 있었는데 업로드 과정이 비효율적이라는 생각이 들었습니다.
점점 공부한 내용을 기록하고 업로드하는 과정이 즐겁지 않아서 업로드 기간이 늘어나고 점점 글을 쓰지 않게 되었습니다.
그래서 업로드 기간이 늘어난 것에 대해 고민을 하다가 vue-django 블로그를 정리하고 GitHub Pages로 블로그를 변경했습니다.
블로그를 바꾸게된 과정과 생각을 이번 글에서 정리해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그로 이전 후기]]></title>
        <id>retrospect/next-blog-migrate</id>
        <link href="https://zamoca.space/retrospect/next-blog-migrate"/>
        <updated>2024-07-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Vuepress에서 Next.js로 블로그를 이전한 후기입니다.]]></summary>
        <content type="html"><![CDATA[
Vuepress를 이용한 블로그를 사용하다가 여러 가지 문제에 부딪히게 되었다.
처음에는 블로그에 최적화된 레이아웃과 마크다운을 사용하는 것이 편했으나,
의존성 충돌이 빈번하게 일어나고 제한적인 플러그인과 트러블 슈팅에 대한 정보가 부족해 한계를 느껴 Next.js로 변경을 고려하게 되었다.

이번 포스트에서는 Next.js로 블로그를 이전하기까지 과정을 정리하고 공유해보려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[오후스튜디오 회원 관리 페이지 개발 후기]]></title>
        <id>retrospect/ohoo-admin</id>
        <link href="https://zamoca.space/retrospect/ohoo-admin"/>
        <updated>2023-10-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
오후스튜디오에서 일하시는 개발자분과 멘토링하면서 실제 DB테이블을 가지고 회원 관리 페이지를 만들어보자고
제안해주셔서 회원 정보, 요금제 정보를 불러오는 페이지를 만들어봤습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[내가 오픈소스에 기여하게된 이유와 2025년 목표]]></title>
        <id>retrospect/oss-contribution</id>
        <link href="https://zamoca.space/retrospect/oss-contribution"/>
        <updated>2025-02-02T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Open-Source"/>
        <category label="Career"/>
        <category label="Growth"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 파일 미리보기 기여 후기]]></title>
        <id>retrospect/oss-gitbutler-binary</id>
        <link href="https://zamoca.space/retrospect/oss-gitbutler-binary"/>
        <updated>2024-10-21T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 관련 이슈 1: https://github.com/gitbutlerapp/gitbutler/issues/2752  
> 관련 이슈 2: https://github.com/gitbutlerapp/gitbutler/issues/3093

이번 후기는 GitButler에서 바이너리 파일(이미지, 폰트파일 등)을 미리보기 기능을 구현한 것에 대한 후기이다.

![UI에서 미리보기 없이 Binary content not shown을 출력한다](https://github.com/user-attachments/assets/bc6269bd-14c0-4874-afc5-526d8ca82dfa)

관련 이슈를 살펴보면 바이너리 파일을 미리보기 기능을 구현하는 것에 대한 이슈가 있었다.  
UI에서 이미지는 미리보기 기능, 이미지 외의 파일에 대한 사이즈 정보를 보여주는 기능을 구현하는 것이 목표였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="GitButler"/>
        <category label="Git"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 리눅스 환경에서 실행시 창이 꺼지는 문제 기여 후기]]></title>
        <id>retrospect/oss-gitbutler-linux-window</id>
        <link href="https://zamoca.space/retrospect/oss-gitbutler-linux-window"/>
        <updated>2024-10-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 해당 이슈: https://github.com/gitbutlerapp/gitbutler/issues/4039

GitButler를 살펴보다 발견한 이슈는 리눅스 환경에서 최대화를 시도하면 창이 자동으로 꺼지는 문제였다.

링크에서 이슈를 살펴보면 Tauri의 window-state와 관련이 있는거 같긴 했지만 Tauri와 의존된 부분이 많아서 정확히 부분을 찾아야했다.

helpwanted 라벨이 달려있어서 해당 이슈에 기여해보고 싶어졌다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="GitButler"/>
        <category label="Linux"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tauri - 리눅스 환경에서 실행시 창이 꺼지는 문제 기여 후기 2]]></title>
        <id>retrospect/oss-tauri-tao</id>
        <link href="https://zamoca.space/retrospect/oss-tauri-tao"/>
        <updated>2024-10-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> [이전 포스트](https://zamoca.space/etc/retrospect/oss-gitbutler-linux-window)에서 이어지는 내용입니다.  
> 해당 이슈: https://github.com/tauri-apps/tao/issues/977

처음에는 linux에서 `Error 71 (Protocol error) dispatching to Wayland display.`가 발생하는 이유는
Tauri의 window-state 플러그인의 자체적인 문제라고 생각했다.

그래서 Tauri의 플러그인 레포지토리에 [이슈](https://github.com/tauri-apps/plugins-workspace/issues/1779)를 남겼지만
창이 최대화시에 발생하는 문제라면 Tauri의 업스트림 중 하나인 Tao에서 발생하는 문제라고 답변을 들을 수 있었다.

![타우리의 아키텍쳐](https://github.com/user-attachments/assets/cc83e09a-0ad6-4da6-9e25-bd812079a2ec)

Tao는 Tauri에서 창을 생성하고 관리하는 라이브러리이다.

그래서 이슈를 Tao에서 다시 작성한 후에 Discord에 메인테이너에게 기여를 해도되는지 문의를 했고
메인테이너에게 자유롭게 기여를 해도된다는 답변을 받았다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Tauri"/>
        <category label="Linux"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-django 블로그 개발 후기]]></title>
        <id>retrospect/vue-django-blog</id>
        <link href="https://zamoca.space/retrospect/vue-django-blog"/>
        <updated>2023-10-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
로봇공학, 인공지능 강의를 들으면서 파이썬에 관심을 가지게 되었고 파이썬으로 공부를 하면서 배운 것을 어떻게 적용해볼 수 있을지 고민했습니다.
마침 인프런에서 vue-django 블로그 만들기가 눈에 들어왔고 만들어서 기술블로그로 사용할 생각으로 AWS에 배포까지 계획했습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Auth.js로 알아보는 세션과 JWT 인증 방식의 차이]]></title>
        <id>js-ts/auth-js</id>
        <link href="https://zamoca.space/js-ts/auth-js"/>
        <updated>2024-08-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Auth.js를 활용하여 개발하면서 세션(Session)과 JWT(JSON Web Token) 인증 방식에 대해 실제로 경험해 볼 수 있었다.
두 방식 모두 쿠키를 사용하기에 각 방식의 특징과 사용 경험을 중심으로 정리해 보았다.

## Auth.js 소개

> 🌐 https://authjs.dev/getting-started

Auth.js는 인증을 쉽게 구현할 수 있게 해주는 강력한 라이브러리다.  
Google 로그인과 같은 OAuth나 이메일 인증 로그인을 지원하며, 세션 및 JWT 기반의 인증을 모두 구현할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JWT"/>
        <category label="Session"/>
        <category label="Next.js"/>
        <category label="Auth.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[date-fns로 Date 객체 다루기]]></title>
        <id>js-ts/date-fns</id>
        <link href="https://zamoca.space/js-ts/date-fns"/>
        <updated>2024-04-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
TODO 앱을 직접 만들어보면서 오늘 날짜를 기준으로 완료 여부를 확인할 수 있는 기능을 만들어보기 위해

date-fns 라이브러리를 사용했다.

## startOfDay, endOfDay

date-fns의 startOfDay와 endOfDay 함수를 사용하면 Date 객체 기준

날짜의 시작 시간과 완료 시간을 보여주는데

오늘의 범위를 0시부터 23시 59분 기준으로 생각하고 함수를 사용하면 생각과 다른 결과가 나온다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="TypeScript"/>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js로 디렉토리 트리 탐색하기]]></title>
        <id>js-ts/node-readdir</id>
        <link href="https://zamoca.space/js-ts/node-readdir"/>
        <updated>2024-06-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[fs.readdir의 recursive 옵션으로 모든 마크다운 파일 찾기]]></summary>
        <content type="html"><![CDATA[
Next.js 블로그 스타터를 시작하면 마크다운 포스트를 가져오는 로직은 `fs.readFileSync()`를 사용하여 컨텐츠 폴더 아래의 파일만 탐색하게 된다.

```ts:lib/api.ts {15}
import { Post } from "@/interfaces/post";
import fs from "fs";
import matter from "gray-matter";
import { join } from "path";

const postsDirectory = join(process.cwd(), "_posts");

export function getPostSlugs() {
  return fs.readdirSync(postsDirectory);
}

export function getPostBySlug(slug: string) {
  const realSlug = slug.replace(/\.md$/, "");
  const fullPath = join(postsDirectory, `${realSlug}.md`);
  const fileContents = fs.readFileSync(fullPath, "utf8");
  const { data, content } = matter(fileContents);

  return { ...data, slug: realSlug, content } as Post;
}
//...
```

하지만 컨텐츠 폴더 내부에 하위 폴더가 존재하면 해당 폴더 내의 파일은 찾지 못하는 문제가 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node.js"/>
        <category label="TypeScript"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[사이드바 정렬 개선하기]]></title>
        <id>js-ts/sidebar-sorting</id>
        <link href="https://zamoca.space/js-ts/sidebar-sorting"/>
        <updated>2024-06-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[폴더, 파일을 문자열 정렬에서 개선해보자]]></summary>
        <content type="html"><![CDATA[
블로그의 사이드바에서 현재 포스트가 가지고 있는 카테고리 폴더와 파일을 보여주려고 컴포넌트를 만들었는데,
정렬 방식이 마음에 들지 않았다.

이를 개선하기 위해 두 가지 목표를 설정했다.

1. 숫자를 포함한 정렬 방식으로 변경
2. 폴더를 파일보다 상위에 배치

![자바스크립트 문자열 방식으로 정렬하고 폴더와 파일의 순서에 구분이 없었다.](https://github.com/Zamoca42/next-blog/assets/96982072/3743a624-545c-48c5-b341-342a722d8a97)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node.js"/>
        <category label="TypeScript"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그에 검색 적용하기 - Docsearch]]></title>
        <id>js-ts/next/blog-docsearch</id>
        <link href="https://zamoca.space/js-ts/next/blog-docsearch"/>
        <updated>2024-07-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
블로그에 검색 기능이 없어서 한글 형태소 지원, 적은 비용, 쉬운 유지보수를 고려한 라이브러리 사용을 고민하다 Typesense와 Aloglia를 알게 되었다.

Algolia는 Vuepress나 공식문서 페이지에서 자주 볼 수 있었는데,
한글 형태소 검색이 지원되고 프리티어로 한달에 요청횟수 10k, 지원 문서 수 100만개까지 적용되어서 사용해봤다.

이번 포스트에서는 Next.js에서 문서 검색을 설정한 과정에서 겪은 일들을 정리하려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Aloglia"/>
        <category label="Next.js"/>
        <category label="TypeScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 14 - HotReload 에러]]></title>
        <id>js-ts/next/hot-reload</id>
        <link href="https://zamoca.space/js-ts/next/hot-reload"/>
        <updated>2024-06-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
NextJS로 프로젝트를 진행하던 중에 [Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)
를 설정해 모달창을 구현하다가 HotReload 에러를 만나게 되었다.

![내가 겪은 에러와 완전히 같아서 참고링크의 사진을 첨부했다.](https://github.com/Zamoca42/blog/assets/96982072/9df58ab8-0822-4079-8e18-072df747b9fd)

Next로 모달을 구현하게되면 Parallel Routes를 자주 사용하게 될텐데 같은 에러가 생기면 다시 해결하기 위해 기록으로 남겨두려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="TypeScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 14 - Lighthouse로 웹페이지 성능 개선하기]]></title>
        <id>js-ts/next/lighthouse</id>
        <link href="https://zamoca.space/js-ts/next/lighthouse"/>
        <updated>2024-07-31T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Next.js 14 정적 블로그에서 성능 개선을 시도한 경험을 이번 포스트에서 정리하려고 한다.
처음에는 웹 성능 측정 도구에 대해 잘 몰라 어떤 지표로 성능을 평가해야 할지 막막했다.

## Lighthouse 도구 발견

![초기 성능 진단 결과](https://github.com/user-attachments/assets/dbea020e-29f7-4ff0-9ccb-d1b175dd4716)

웹 성능 최적화에 대해 검색하던 중 Google에서 제공하는 Lighthouse라는 도구를 알게 되었다.
Lighthouse는 웹페이지의 성능, 접근성, SEO 등 다양한 측면을 분석해주는 강력한 도구였다.

![초기 진단 항목들 중 LCP와 FCP에 영향을 주는 항목이 눈에 띈다.](https://github.com/user-attachments/assets/2bdd2c27-9fe1-448b-a16f-346680ecf0a7)

프로덕션 환경에서 실행 결과, Largest Contentful Paint(LCP)이 눈에 띄는데  
진단 항목을 살펴보면 이미지가 주된 원인이였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Lighthouse"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[마크다운 플러그인 세팅]]></title>
        <id>js-ts/next/markdown-plugin</id>
        <link href="https://zamoca.space/js-ts/next/markdown-plugin"/>
        <updated>2024-07-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[마크다운 플러그인인 remark, rehype와 react-markdown에 대해 알아보자]]></summary>
        <content type="html"><![CDATA[
정적 블로그를 만들 때 마크다운 파일을 사용하는 경우, 단순히 `<div>` 태그와 `dangerouslySetInnerHTML` 속성으로 정적 콘텐츠를 삽입할 수 있다.

하지만 이 방법으로는 추가적인 커스터마이징이 어렵다.

이를 해결하기 위해 `next-mdx-remote`와 같은 라이브러리와 `remark` 같은 플러그인을 사용하면 HTML 코드를 원하는 대로 수정할 수 있다.

Next.js 공식 문서에서는 MDX를 이용한 정적 블로그 예시를 제공하고 있다.
하지만 이미 마크다운 형식으로 포스트를 작성해왔기 때문에 MDX로 변환할 필요성을 느끼지 못했다. `next-mdx-remote`에서 옵션으로 `.md` format을 지원하지만
설정하는 방법이 직관적이라는 생각이 들지 않아서 [react-markdown](https://github.com/remarkjs/react-markdown)
을 사용하기로 결정했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="React"/>
        <category label="Markdown"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Auth.js v4 - Unknown arg `access_token`... 에러]]></title>
        <id>js-ts/next/prisma-token-schema-error</id>
        <link href="https://zamoca.space/js-ts/next/prisma-token-schema-error"/>
        <updated>2024-06-13T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Auth.js는 NextJS 친화적으로 설계된 오픈소스 인증 라이브러리다.

NextJS에서 간단한 설정만으로 OAuth나 이메일 인증 로직을 적용할 수 있어 편리하다.

다만 커스터마이징을 하기에는 사용자가 내부로직을 알기 모호하고 문서가 복잡하고 불친절하다는 느낌을 받았다.

그 예로 NextJS에서 Prisma를 이용해 구글 이메일 로그인을 구현하면서 겪은 에러에 대해 정리하려고 한다.

해당 내용은 Auth.js v4에서 겪은 에러로 내용은 다음과 같다.

```txt:에러내용
Unknown arg `access_token` in data.access_token for type AccountUncheckedCreateInput. Did you mean `accessToken`?
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Auth.js"/>
        <category label="Prisma"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js - 빌드 타임에 스크립트를 실행하는 방법]]></title>
        <id>js-ts/next/run-script-build-time</id>
        <link href="https://zamoca.space/js-ts/next/run-script-build-time"/>
        <updated>2024-06-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What's the recommended way to run a script at build time?]]></summary>
        <content type="html"><![CDATA[
마크다운 컨텐츠를 활용한 블로그를 만들면서 포스트의 생성일과 수정일을 커밋 날짜를 기준으로 블로그에 보여주려고 했다.

git 명령어를 [node.js의 child_process](https://www.freecodecamp.org/korean/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/)
로 실행하면서 개발서버에서는 이상없이 돌아갔으나...

Vercel에 배포 할때는 `.git` 레포지토리가 포함되지 않기 때문에 git 명령어를 사용할 수 없다고 한다.

![vercel command failed](https://github.com/Zamoca42/blog/assets/96982072/4cdbfb40-d459-424a-966b-4794e5b13f90)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Node"/>
        <category label="Script"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js - SEO와 검색엔진 등록]]></title>
        <id>js-ts/next/seo</id>
        <link href="https://zamoca.space/js-ts/next/seo"/>
        <updated>2024-07-24T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
구글과 네이버 같은 검색엔진은 크롤링 봇이 있는데 크롤링 봇이 웹사이트와 웹페이지를 수집하고 등록시켜 검색하는 유저에게 노출한다.
SEO(Search Engine Optimization)는 검색엔진 크롤링 봇에게 내 웹페이지를 수집하기 쉽도록 개선하는 작업을 말한다.  
SEO를 직접 제공하는 블로그 서비스를 이용하는 것이 아닌 이상 자동으로 검색엔진에 등록되는일은 없으므로 SEO를 위한 작업이 필요하다.

Next.js 14버전의 App router를 기준으로 진행한 SEO 작업들을 정리하려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SEO"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[고객정보 API 만들기]]></title>
        <id>js-ts/nest-js/api</id>
        <link href="https://zamoca.space/js-ts/nest-js/api"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![회원 정보 검색](https://github.com/Zamoca42/blog/assets/96982072/3cb4e5b5-b460-470e-8c80-f65a1502ed44)

이렇게 클라이언트에서 회원아이디를 입력했을때 회원의 정보를 보여주려고합니다

```json
{
  "id": "sdfsdf333",
  "phoneNumber": "+821099990001",
  "email": "이메일@.com",
  "businessName": "회사이름",
  "businessItem": "사업"
}
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Project"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[응답 객체 직렬화하기]]></title>
        <id>js-ts/nest-js/class-transformer</id>
        <link href="https://zamoca.space/js-ts/nest-js/class-transformer"/>
        <updated>2023-12-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
요청 객체를 역직렬화 과정과 마찬가지로 클라이언트에 데이터를 전달할 때
응답 객체를 인스턴스로 변환하는데 NestJS에서는 `class-transformer`를 사용한다.

한 객체가 변경이 발생하면 해당 객체에 의존하는 다른 객체들도 변경해야 하기 때문에 이들의 변경 범위를 최소화 하기 위해 캡슐화를 사용한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Class-Transformer"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[요청 객체 역직렬화하기]]></title>
        <id>js-ts/nest-js/class-validator</id>
        <link href="https://zamoca.space/js-ts/nest-js/class-validator"/>
        <updated>2023-12-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
클라이언트에서 HTTP 요청시 JSON이나 쿼리스트링의 경우 클래스 인스턴스로 변환하는 역직렬화와 유효성 검사과정이 필요하다.

이 부분은 `class-validator` 패키지가 필요하다.
[`class-validator`][class-validator]는 데코레이터를 기반으로 Dto들의 검증을 담당한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Class-Validator"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Custom validation 만들기]]></title>
        <id>js-ts/nest-js/custom-validator</id>
        <link href="https://zamoca.space/js-ts/nest-js/custom-validator"/>
        <updated>2023-11-07T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
위도, 경도에 대한 범위를 넣어서 검증하는 validator를 만들어 보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DTO (Data Transfer Object)]]></title>
        <id>js-ts/nest-js/dto</id>
        <link href="https://zamoca.space/js-ts/nest-js/dto"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## DTO란?

DTO(Data Transfer Object)는 **계층간 데이터 교환**을 하기 위해 사용하는 객체로
로직을 가지지 않은 객체이고 getter, setter 메서드만 가진 클래스를 의미합니다.

![Layered 아키텍쳐](https://github.com/Zamoca42/blog/assets/96982072/9460d59f-2b48-445c-85ca-23f9b7021520)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[sh 1 nest not found 오류]]></title>
        <id>js-ts/nest-js/error-cli-not-found</id>
        <link href="https://zamoca.space/js-ts/nest-js/error-cli-not-found"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
도커를 이미지화 하거나 배포시 인스턴스에서 `sh: 1: nest: not found`를 자주 보게 되는데
왜 이런 오류가 발생하는지 어떻게 해결했는지 포스트로 기록한다.

![Render로 배포시 발생한 not found 오류](https://github.com/develop-pix/dump-in-Admin-BE/assets/96982072/bf72345c-c77e-48b3-a173-41d3a702ca19)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Error"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[전역으로 예외 처리 적용하기]]></title>
        <id>js-ts/nest-js/error-exception</id>
        <link href="https://zamoca.space/js-ts/nest-js/error-exception"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Nest에는 애플리케이션 전체에서 처리되지 않은 모든 예외를 처리하는 예외 계층(Exceptions Layer)이 내장되어 있습니다.
애플리케이션 코드에서 예외가 처리되지 않으면 이 계층에서 이를 포착한 다음 사용자에게 응답을 내보냅니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[서비스 레이어에서 예외처리 분리하기]]></title>
        <id>js-ts/nest-js/exception</id>
        <link href="https://zamoca.space/js-ts/nest-js/exception"/>
        <updated>2024-01-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
서비스 레이어에서 예외처리를 하고있었는데 [좋은 예외(Exception) 처리][exception-blog]에서
글을 보고 의문이 들어 리팩터링을 진행했는데 포스트로 정리하려고한다.
소제목 파트인 정상적인 흐름에서 Catch 금지, Layer에 맞는 예외 보고 의문이 들기 시작했다.

![어디서 많이 본 로직이 보였다.](https://github.com/develop-pix/dump-in-Admin-BE/assets/96982072/ef451050-bdfe-4e59-a4c1-7030c6f181aa)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="TypeORM"/>
        <category label="Error"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[외부 로거로 효율적으로 모니터링하기]]></title>
        <id>js-ts/nest-js/external-logger</id>
        <link href="https://zamoca.space/js-ts/nest-js/external-logger"/>
        <updated>2023-12-27T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
로컬에서는 에러가 발생했을 때 터미널에서 로그메세지를 확인할 수 있지만 배포환경에서는 로그를 남겨야 어떤 문제가 발생했는지 알 수 있다.

처음에는 모든 로그를 남겨서 확인하려고했으나 로그를 찾아서 확인하는 것도 번거로운 일이였다.
그래서 예상할 수 있는 예외는 제외하고 심각한 로그를 구분해서 알림을 만드는 것이 필요했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Winston"/>
        <category label="Sentry"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[프로젝트 시작하기]]></title>
        <id>js-ts/nest-js/introduction</id>
        <link href="https://zamoca.space/js-ts/nest-js/introduction"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 소개

Nest(NestJS)는 Node.js에 기반한 프레임워크로 Express나 Fastify를 사용하여 동작합니다

#### with Express (default)

```typescript
import * as session from "express-session";

// somewhere in your initialization file
app.use(
  session({
    secret: "my-secret",
    resave: false,
    saveUninitialized: false,
  })
);
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[로그인 구현하기]]></title>
        <id>js-ts/nest-js/login-module</id>
        <link href="https://zamoca.space/js-ts/nest-js/login-module"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
React Admin에서 로그인 페이지를 만들고 Nest의 인증 모듈과 연결했을 때의 화면입니다.

![로그인 화면](https://github.com/Zamoca42/blog/assets/96982072/9218fafc-bc81-4780-b22b-4274e3f3ec6b)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[API 요청 시도 횟수 제한하기]]></title>
        <id>js-ts/nest-js/rate-limit</id>
        <link href="https://zamoca.space/js-ts/nest-js/rate-limit"/>
        <updated>2023-12-15T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
외부에서 로그인 시도할 때 횟수에 제약이 없다는 것은 무작위 반복해서 아이디와 비밀번호를 대입해도 막을 방법이 없다.
이를 막을 방법에는 세션에 로그인 시도를 기록하는 방법이 있고, 일정 로그인 횟수 이상으로 시도시 ip를 차단하는 방법도 있을 것이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Express"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[서버 상태 모니터링하기]]></title>
        <id>js-ts/nest-js/server-monitoring</id>
        <link href="https://zamoca.space/js-ts/nest-js/server-monitoring"/>
        <updated>2023-12-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
[외부 로거 도입](./external-logger.md)해서 Sentry로 error 레벨의 로그를 알림을 받도록 했었다.
Sentry의 기능 중에 크론 모니터링 기능이 있어서 NestJS가 지원하는 스케쥴러로 주기적으로 서버 상태를 모니터링하려고 했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Sentry"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[세션 쿠키 인증/인가]]></title>
        <id>js-ts/nest-js/session</id>
        <link href="https://zamoca.space/js-ts/nest-js/session"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
NestJS에서 [express-session][express-session]으로 세션 인증을 구현해보면서 알게된 점을 정리해보려고 합니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Express"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[스택 트레이스로 에러 추적하기]]></title>
        <id>js-ts/nest-js/stack-trace</id>
        <link href="https://zamoca.space/js-ts/nest-js/stack-trace"/>
        <updated>2023-11-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
기존의 예외 처리 설정에서는 BadRequestException이 발생하면
오류가 발생한 url이나 메세지 정도는 보여줬지만, 정확한 위치나 내용은 알 수 없었습니다.

스택 트레이스를 넣어보면서 에러의 위치나 내용을 자세히 넣는 기능을 넣어보고
내장 로거대신 winston 로거 설정을 추가해서 읽기 좋은 로거를 만들어 보려고 합니다.

## 스택 트레이스란?

스택 트레이스는 예외가 어디에서 발생했는지, 어떤 함수 호출 순서가 예외를 유발했는지 등을
나타내는 정보를 로그에 추가해 디버깅 및 예외 추적 시 도움이 됩니다.

NestJS에서는 Error 객체에 stack 프로퍼티를 사용해서 스택 트레이스를 볼 수 있습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Winston"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stub을 이용한 단위 테스트 적용하기]]></title>
        <id>js-ts/nest-js/unit-test</id>
        <link href="https://zamoca.space/js-ts/nest-js/unit-test"/>
        <updated>2023-12-27T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Test"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[10. 객체 리터럴]]></title>
        <id>js-ts/deepdive/deepdive10</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive10"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 객체란?

자바스크립트는 객체 기반의 프로그래밍 언어이며, 원시 값을 제외한 나머지 값은 모두 객체다.
원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체는 변경 가능한 값(mutable value)이다.

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.

![10-1](https://github.com/Zamoca42/blog/assets/96982072/30727ee8-b9c9-4c6a-b5e7-a974189d3cca)

프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.

![10-2](https://github.com/Zamoca42/blog/assets/96982072/e9dd00c6-7cec-481e-aa6e-3a8bf9d935da)

프로퍼티와 메서드의 역할은 다음과 같다

- 프로퍼티: 객체의 상태를 나타내는 값(data)
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

이처럼 객체는 객체의 상태를 나타내는 값과 프로퍼티를 참조하고 조작할 수 있는 메서드를
모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.

![10-3](https://github.com/Zamoca42/blog/assets/96982072/59e3746c-4e49-44b9-9eb5-3a45167f4e8b)

객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 객체지향 프로그래밍이라 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[11. 원시 값과 객체의 비교]]></title>
        <id>js-ts/deepdive/deepdive11</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive11"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트에서 값은 크게 원시 타입과 객체 타입으로 구분할 수 있다.

- **원시 타입**의 값은 변경 불가능한 값이며, 변수에 할당될 때 **값에 의한 전달**로 동작한다.
- **객체 타입**의 값은 변경 가능한 값이며, 변수에 할당될 때 **참조에 의한 전달**로 동작한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[12. 함수]]></title>
        <id>js-ts/deepdive/deepdive12</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive12"/>
        <updated>2023-09-29T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 함수란?

함수는 자바스크립트에서 가장 중요한 핵심 개념이다.
또 다른 자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[13. 스코프]]></title>
        <id>js-ts/deepdive/deepdive13</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive13"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 스코프란?

스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다.

스코프는 변수와 함수의 유효한 범위를 나타낸다.

```js
function add(x, y) {
  console.log(x, y);
  return x + y;
}

add(2, 5);

// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x, y); // ReferenceError
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[14. 전역 변수의 문제점]]></title>
        <id>js-ts/deepdive/deepdive14</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive14"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
전역 변수의 무분별한 사용은 위험하다.

전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다.

이번 장에서는 전역 변수의 문제점과 전역 변수의 사용을 억제할 수 있는 방법을 살펴보자.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[15. let, const 키워드와 블록 레벨 스코프]]></title>
        <id>js-ts/deepdive/deepdive15</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive15"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. var 키워드로 선언한 변수의 문제점

ES5까지 변수를 선언할 수 있는 유일한 방법은 `var` 키워드를 사용하는 것이었다.  
var 키워드로 선언된 변수는 다음과 같은 특징이 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[16. 프로퍼티 어트리뷰트]]></title>
        <id>js-ts/deepdive/deepdive16</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive16"/>
        <updated>2023-10-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 내부 슬롯과 내부 메서드

내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다.

ECMAScript 사양에 등장하는 이중 대괄호(`[[...]]`)으로 감싼 이름들이 내부 슬롯과 내부 메서드다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[17. 생성자 함수에 의한 객체 생성]]></title>
        <id>js-ts/deepdive/deepdive17</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive17"/>
        <updated>2023-10-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번 장에서는 생성자 함수를 사용하여 객체를 생성하는 방식을 살펴보고, 객체 리터럴을 사용하여 객체를 생성하는 방식과의 장단점을 비교해보자.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[18. 함수와 일급 객체]]></title>
        <id>js-ts/deepdive/deepdive18</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive18"/>
        <updated>2023-10-04T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 일급 객체

자바스크립트의 함수는 다음 조건을 모두 만족하는 **일급 객체**다.

1. 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[19. 프로토타입]]></title>
        <id>js-ts/deepdive/deepdive19</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive19"/>
        <updated>2023-10-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트는 프로토타입을 기반으로 상속을 구현하여 객체 지향 프로그래밍 능력을 지니고 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[20. strict mode]]></title>
        <id>js-ts/deepdive/deepdive20</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive20"/>
        <updated>2023-10-11T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. strict mode란?

strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나
자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

예를 들어, 선언하지 않은 변수를 참조하면 암묵적으로 전역 변수가 생성되는 현상(암묵적 전역)은 오류를 발생시키는 원인이 될 수 있다. strict mode에서는 이를 에러로 인식한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[21. 빌트인 객체]]></title>
        <id>js-ts/deepdive/deepdive21</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive21"/>
        <updated>2023-10-12T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[22. this]]></title>
        <id>js-ts/deepdive/deepdive22</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive22"/>
        <updated>2023-10-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. this 키워드

메서드에서 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 사용해야 한다.  
이때 사용되는 것이 this 키워드다.

```js
const circle = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  },
};

console.log(circle.getDiameter()); // 10
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[23. 실행 컨텍스트]]></title>
        <id>js-ts/deepdive/deepdive23</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive23"/>
        <updated>2023-10-15T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[24. 클로저]]></title>
        <id>js-ts/deepdive/deepdive24</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive24"/>
        <updated>2023-10-18T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[25. 클래스]]></title>
        <id>js-ts/deepdive/deepdive25</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive25"/>
        <updated>2023-10-23T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[26. ES6 함수의 추가 기능]]></title>
        <id>js-ts/deepdive/deepdive26</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive26"/>
        <updated>2023-10-29T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[27. 배열]]></title>
        <id>js-ts/deepdive/deepdive27</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive27"/>
        <updated>2023-10-30T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[34. 이터러블]]></title>
        <id>js-ts/deepdive/deepdive34</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive34"/>
        <updated>2023-11-09T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[35. 스프레드 문법]]></title>
        <id>js-ts/deepdive/deepdive35</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive35"/>
        <updated>2023-11-12T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[36. 디스트럭처링 할당]]></title>
        <id>js-ts/deepdive/deepdive36</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive36"/>
        <updated>2023-11-13T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[37. Set과 Map]]></title>
        <id>js-ts/deepdive/deepdive37</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive37"/>
        <updated>2023-11-15T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[38. 브라우저의 렌더링 과정]]></title>
        <id>js-ts/deepdive/deepdive38</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive38"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[39. DOM]]></title>
        <id>js-ts/deepdive/deepdive39</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive39"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[4. 변수]]></title>
        <id>js-ts/deepdive/deepdive4</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive4"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 변수란 무엇인가?

- 컴퓨터는 데이터를 메모리에 저장하거나 읽어들임

  - 메모리는 메모리 셀의 집합체

  - 각 셀은 고유의 메모리 주소를 갖는다

    - 4GB 메모리의 주소는 0x00000000 ~ 0xffffffff

- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름

  - 변수에 값을 저장하는 것을 **할당(대입, 저장)**

  - 변수에 저장된 값을 읽어 들이는 것을 **참조**

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[40. 이벤트]]></title>
        <id>js-ts/deepdive/deepdive40</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive40"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 이벤트 드리븐 프로그래밍

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.
예를 들어, 클릭, 키보드 입력, 마우스 이동 등이 일어나면 브라우저는 이를 감지하여 특정한 타입의 이벤트를 발생시킨다.

이벤트가 발생했을 때 호출될 함수를 이벤트 핸들러라 하고,
이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다.

브라우저는 사용자 버튼 클릭을 감지하여 클릭 이벤트를 발생시킬 수 있다.
그리고 특정 버튼 요소에서 클릭 이벤트가 발생하면 이벤트 핸들러를 호출하도록 브라우저에게 위임할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[41. 타이머]]></title>
        <id>js-ts/deepdive/deepdive41</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive41"/>
        <updated>2023-11-20T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[42. 비동기 프로그래밍]]></title>
        <id>js-ts/deepdive/deepdive42</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive42"/>
        <updated>2023-11-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트는 함수를 호출하면 실행 컨텍스트 스택에 푸시되고 순차적으로 함수 코드가 실행된다.

![그림 42-1. 실행 컨텍스트 스택](https://github.com/Zamoca42/blog/assets/96982072/fa7ba17d-3430-4ecd-9858-118ddadd6453)

자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작하기 때문에
처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹이 발생한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[43. Ajax]]></title>
        <id>js-ts/deepdive/deepdive43</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive43"/>
        <updated>2023-11-21T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[45. 프로미스]]></title>
        <id>js-ts/deepdive/deepdive45</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive45"/>
        <updated>2023-11-22T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[46. 제너레이터와 async/await]]></title>
        <id>js-ts/deepdive/deepdive46</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive46"/>
        <updated>2023-11-23T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[47. 에러처리]]></title>
        <id>js-ts/deepdive/deepdive47</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive47"/>
        <updated>2023-11-25T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[48. 모듈]]></title>
        <id>js-ts/deepdive/deepdive48</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive48"/>
        <updated>2023-11-26T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[5. 표현식과 문]]></title>
        <id>js-ts/deepdive/deepdive5</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive5"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 값

값(value)는 표현식(expression)이 평가되어 생성된 결과를 말한다.

```javascript
// 10 + 20은 평가되어 숫자 값 30을 생성
10 + 20; // 30
```

변수는 **하나의 값**을 저장하기 위해 확보한 메모리 공간

```javascript
var sum = 10 + 20;
```

sum변수에 할당되는 것은 10 + 20이 아니라 30이라는 값이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[6. 데이터 타입]]></title>
        <id>js-ts/deepdive/deepdive6</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive6"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트의 모든 값은 데이터 타입을 갖는다.
데이터 타입(Data type)은 값의 종류를 말한다.

자바스크립트(ES6)은 7개의 데이터 타입을 제공하고
원시 타입(Primitive type)과 객체 타입(Object type)으로 분류할 수 있다.

<table>
  <tr>
    <th>구분</th>
    <th>데이터 타입</th>
    <th>설명</th>
  </tr>
  <tr>
    <td rowspan="6">원시 타입</td>
    <td>숫자(number)</td>
    <td>정수와 실수 구분 없이 하나의 숫자 타입만 존재</td>
  </tr>
  <tr>
    <td>문자열(string)</td>
    <td>문자열</td>
  </tr>
  <tr>
    <td>불리언(boolean)</td>
    <td>논리적 참(true)과 거짓(false)</td>
  </tr>
  <tr>
    <td>undefined</td>
    <td>var 키워드로 선언된 변수에 암묵적으로 할당되는 값</td>
  </tr>
  <tr>
    <td>null</td>
    <td>값이 없다는 것을 의도적으로 명시할 때 사용하는 값</td>
  </tr>
  <tr>
    <td>심벌(symbol)</td>
    <td>ES6에서 추가된 7번째 타입</td>
  </tr>
  <tr>
    <td colspan="2">객체 타입</td>
    <td>객체, 함수, 배열 등</td>
  </tr>
</table>

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. 연산자]]></title>
        <id>js-ts/deepdive/deepdive7</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive7"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
연산자(Operator)는 하나 이상의 표현식을 대상으로, 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

이때 연산의 대상을 피연산자(Operand)라 한다.

```javascript
// 산술 연산자
5 * 4; // -> 20

// 문자열 연결 연산자
"My name is " + "Lee"; // -> 'My name is Lee'

// 할당 연산자
color = "red"; // -> 'red'

// 비교 연산자
3 > 5; // -> false

// 논리 연산자
true && false; //-> false

// 타입 연산자
typeof "Hi"; //-> string
```

연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. 제어문]]></title>
        <id>js-ts/deepdive/deepdive8</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive8"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.
일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.
제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.

## 1. 블록문

블록문(block statement)는 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라 부르기도 한다.

```javascript
// 블록문
{
  var foo = 10;
}

// 제어문
var x = 1;

if (x < 10) {
  x++;
}

// 함수 선언문
function sum(a, b) {
  return a + b;
}
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[9. 타입 변환과 단축 평가]]></title>
        <id>js-ts/deepdive/deepdive9</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive9"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 타입 변환이란?

개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적(Explicit) 타입 변환**
또는 **타입 캐스팅**이라 한다

```js
var x = 10;

var str = x.toString();
console.log(typeof str, str); // string 10

console.log(typeof x, x); //number 10
```

개발자의 의도와는 상관 없이 표현식을 평가하는 도중에 암묵적으로 타입이 자동 변환 되기도 한다.

이를 **암묵적(Implicit) 타입 변환** 또는 **타입 강제 변환**이라 한다.

```js
var x = 10;

var str = x + "";
console.log(typeof str, str); //string 10

console.log(typeof x, x); //number 10
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 페어소스 기반의 Git 버전 관리 자동화 툴]]></title>
        <id>etc/git-butler</id>
        <link href="https://zamoca.space/etc/git-butler"/>
        <updated>2024-10-18T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://news.hada.io/topic?id=16281

## GitButler 소개

GitButler를 처음 설치하고 실행했을 때는 Source Tree와 Git Desktop, AI를 합쳐놓은 듯한 소프트웨어같은 느낌을 받았다.

흔히 CLI를 통해 git 명령어를 입력하는 것과 달리 GUI로 좀 더 쉽게 버전 관리를 할 수 있도록 도와준다.

직접 사용해보면서 느낀점은 AI를 통해 커밋 메시지를 자동으로 생성해주는 것이 아주 편리하다는 점이였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="AI"/>
        <category label="Architecture"/>
        <category label="Rust"/>
        <category label="Svelte"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git-flow]]></title>
        <id>etc/git-flow</id>
        <link href="https://zamoca.space/etc/git-flow"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![git flow](https://user-images.githubusercontent.com/96982072/227922966-e7f04bb8-7943-434b-8a8a-cbb4097a0339.png)

git-flow는 브랜치를 5가지 종류로 구분하여 개발하는 전략이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="Strategy"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub-flow]]></title>
        <id>etc/github-flow</id>
        <link href="https://zamoca.space/etc/github-flow"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![GitHub-flow](https://user-images.githubusercontent.com/96982072/227937502-73a8e6cd-1c9d-4a9f-93b0-0141d95f06c6.png)

## GitHub-flow의 브랜칭 전략

- 수시로 배포가 일어나며, CI와 배포가 자동화된 프로젝트
- Release Branch가 명확하게 구분되지 않은 시스템
- Pull Request 기능을 사용

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="Strategy"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[VSCode - 커스텀 스니펫과 키 바인딩]]></title>
        <id>etc/key-binding</id>
        <link href="https://zamoca.space/etc/key-binding"/>
        <updated>2024-06-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[코드 스니펫을 VSCode에 단축키로 등록해 자동입력하기]]></summary>
        <content type="html"><![CDATA[
> https://code.visualstudio.com/docs/editor/userdefinedsnippets#_assign-keybindings-to-snippets

VSCode에서는 커스텀 스니펫과 키 바인딩 기능을 제공한다.

이를 활용하면 자주 사용하는 코드나 텍스트를 단축키나 단축어로 쉽게 입력할 수 있다.
블로그 포스트를 작성 시 매번 frontmatter나 excerpt 키워드를 복사하여 붙여넣는 번거로움을 줄이기 위해 VSCode의 이 기능을 사용해 보기로 했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="VSCode"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdownlint - 마크다운 linting 도구]]></title>
        <id>etc/markdown-lint</id>
        <link href="https://zamoca.space/etc/markdown-lint"/>
        <updated>2024-06-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Markdownlint는 VSCode 확장 프로그램 중 하나로, 마크다운 형식의 파일을 일관성있게 작성하도록 도와주는 도구다.

![https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint](https://github.com/Zamoca42/next-blog/assets/96982072/13d22865-eed5-46b1-b2bd-503f81cafa12)

블로그를 작성할 때 주로 사용하고있고, VSCode 설정에서 `codeActionsOnSave` 설정 시 자동으로 규칙과 어긋난 부분을 수정한다.

```diff-json:settings.json
    //...
    "editor.codeActionsOnSave": {
        "source.fixAll": "explicit",
+       "source.fixAll.markdownlint": "explicit"
    },
    //...
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Markdown"/>
        <category label="VSCode"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그 마크다운 문법 정리]]></title>
        <id>etc/markdown</id>
        <link href="https://zamoca.space/etc/markdown"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
<!-- markdownlint-disable -->

## 마크다운(Markdown)이란?

마크다운(Markdown)은 텍스트 기반의 가벼운 마크업 언어 중 하나로, 읽기 쉽고 쓰기 쉬운 문법을 가지고 있다.

마크다운은 HTML로 변환이 가능하며, 다양한 플랫폼과 프로그램에서 지원되고 있다.

마크다운을 사용하면 **간단한 문법**으로 서식이 있는 문서를 작성할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Markdown"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[프로메테우스 - 그라파나 in Django]]></title>
        <id>etc/infra/grafana-prometheus-in-django</id>
        <link href="https://zamoca.space/etc/infra/grafana-prometheus-in-django"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 왜 그라파나와 프로메테우스 인가?

Datadog, Sentry와 같이 여러 데이터를 시각화해서 보여주는 앱들이 많지만
그라파나와 프로메테우스는 오픈 소스 도구로 비용이 들지 않고 다양하게 커스터마이징할 수 있다는 장점이 있었다.
나는 프로젝트를 해오면서 모니터링 도구를 사용해본 적 없기 때문에 그라파나와 프로메테우스를 포토부스 프로젝트의 첫 모니터링 도구로 설정해보게 되었다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Monitoring"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[우분투에 node & npm 설치]]></title>
        <id>etc/infra/node-install</id>
        <link href="https://zamoca.space/etc/infra/node-install"/>
        <updated>2024-03-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로젝트의 서버는 NestJS를 사용하고 있다.
NestJS로 구성된 서버를 실행하려면 node와 npm이 있어야 패키지를 관리하고 실행할 수 있다.
하지만 기본적으로 EC2 인스턴스를 만들면 Node.js와 npm 등이 설치되어 있지 않다.

그래서 aws에서 ec2 인스턴스를 만들 때 기본 제공되는 unbuntu 이미지에 Node.js와 npm 설치하고
git clone으로 레포지토리까지 설정을 한 다음,
초기 설정한 볼륨을 이미지(AMI)로 만들어서 자동으로 생성된 인스턴스에 초기설정이 필요없게 만들려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node"/>
        <category label="NPM"/>
        <category label="EC2"/>
        <category label="Linux"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[CI/CD란?]]></title>
        <id>etc/infra/github-actions/ci-cd</id>
        <link href="https://zamoca.space/etc/infra/github-actions/ci-cd"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> CI/CD 개념 부분은 참고 링크의 레드햇 기술블로그와 요즘 IT의 CI/CD 개념과 깃허브 리포지터리 생성하기 부분의 개념 부분을 참조했습니다.

CI/CD (Continuous Integration/Continuous Delivery)는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는
통합 지옥(integration hell)을 자동화하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법입니다.
CI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포입니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CI"/>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[EC2에 Django 서버 배포하기]]></title>
        <id>etc/infra/github-actions/ec2-deploy</id>
        <link href="https://zamoca.space/etc/infra/github-actions/ec2-deploy"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번 글에서는 GitHub Actions에서 AWS CodeDeploy에 전달하고 EC2에 Django 서버를 배포하는 것까지 진행해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Actions]]></title>
        <id>etc/infra/github-actions/github-actions</id>
        <link href="https://zamoca.space/etc/infra/github-actions/github-actions"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://docs.github.com/ko/actions - GitHub Actions 공식 문서

Github Actions에 대해 간단히 설명하면 테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼입니다.
레포지토리에서 push같은 이벤트가 일어날 때, workflow를 통해 작업이 실행되는 자동화 프로세스로 각 작업은 자체 가상머신을 사용하여 실행됩니다.

이번에는 GitHub Actions를 사용해서 AWS EC2에는 서버를 배포하고 S3에는 정적 웹페이지에 배포를 자동화 해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CI"/>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[S3에 정적 웹페이지 배포하기]]></title>
        <id>etc/infra/github-actions/s3-deploy</id>
        <link href="https://zamoca.space/etc/infra/github-actions/s3-deploy"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
AWS S3 버킷에 vue로 빌드한 페이지를 정적 웹 사이트로 호스팅할 수 있습니다.

- [Amazon S3를 사용하여 정적 웹 사이트 호스팅](https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/WebsiteHosting.html?icmpid=docs_amazons3_console)

S3 버킷을 정적 웹사이트로 호스팅하기 위해서는 다음과 같은 설정이 필요합니다.

1. 퍼블릭 액세스 설정
2. 버킷 정책 설정
3. CORS 설정

이렇게 버킷을 설정하는 방법을 알아보고 GitHub Actions에서 배포 설정을 자동화 해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DevContainer - VSCode(IDE)에서 리눅스 환경으로 개발하고 디버깅하기]]></title>
        <id>etc/infra/docker/dev-container</id>
        <link href="https://zamoca.space/etc/infra/docker/dev-container"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## DevContainer란 무엇인가?

> [VS Code로 컨테이너 안에서 개발하기](https://ssowonny.medium.com/vs-code%EB%A1%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%95%88%EC%97%90%EC%84%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-d8ed0950d69a)
>
> [Developing inside a Container - vscode 문서](https://code.visualstudio.com/docs/devcontainers/containers)

DevContainer는 주로 Visual Studio Code와 같은 통합 개발 환경(IDE)에서 사용되며,
Visual Studio Code의 확장 앱을 통해 구성할 수 있습니다.
이를 통해 프로젝트를 개발하는 동안 개발 환경을 컨테이너 내에서 실행하고 호스트 시스템과 분리시키는 것이 가능합니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Docker"/>
        <category label="Debug"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[자주 사용하는 git 명령어 모음]]></title>
        <id>etc/git/cheat-sheet</id>
        <link href="https://zamoca.space/etc/git/cheat-sheet"/>
        <updated>2024-04-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 설정

**vscode로 git 설정**

```shell
git config --global core.editor "code --wait"
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[필요한 디렉터리만 clone하기]]></title>
        <id>etc/git/git-sparse-checkout</id>
        <link href="https://zamoca.space/etc/git/git-sparse-checkout"/>
        <updated>2024-03-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
현재 프로젝트 레포지토리의 디렉터리 구조는 이렇게 되어있다.

> :file_folder: toeic  
> ├─ :file_folder: backend/  
> ├─ :file_folder: frontend/  
> ├─ package-lock.json  
> └─ package.json

GitHub 레포지토리에서 frontend 디렉터리를 제외한 나머지 파일 및 디렉터리를 clone해서 가져오려면 어떻게 해야할까?

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[merge]]></title>
        <id>etc/git/merge</id>
        <link href="https://zamoca.space/etc/git/merge"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
git에서 브랜치와 다른 브랜치를 합치는 명령어가 `merge`

## merge 명령어

브랜치와 다른 브랜치를 합치기 위해서 최종으로 합치고싶은 브랜치로 이동

예를 들어, `post`라는 브랜치와 `main`이라는 브랜치가 존재

`main`에 `post`를 합치고 싶다면 `main` 브랜치로 이동

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DynamoDB 연결하기 with NestJS]]></title>
        <id>etc/db/dynamoose</id>
        <link href="https://zamoca.space/etc/db/dynamoose"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Nest에서는 TypeORM, Prisma, Mongoose 등 다양한 ORM을 사용할 수 있기 때문에
SQL이나 NoSQL 데이터베이스 모두 쉽게 연결할 수 있습니다.

이번 주제에서는 AWS의 대표적인 NoSQL 기반 데이터베이스인 DynamoDB를 Dynamoose를 이용해서 연결해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="DynamoDB"/>
        <category label="Dynamoose"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma - 인스턴스 경고 해결하기]]></title>
        <id>etc/db/prisma-instance</id>
        <link href="https://zamoca.space/etc/db/prisma-instance"/>
        <updated>2024-05-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Next.js에서 Prisma를 사용하여 로컬 개발 환경에서 작업하다 보면, 터미널에 다음과 같은 경고 메시지가 나타나는 경우가 있다.

```txt
warn(prisma-client) There are already 10 instances of Prisma Client actively running.
```

이 글에서는 이 경고 메시지가 발생하는 이유와 해결 방법에 대해 알아보려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Prisma"/>
        <category label="MySQL"/>
        <category label="PlanetScale"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma - relationMode 에러]]></title>
        <id>etc/db/prisma-relation-mode</id>
        <link href="https://zamoca.space/etc/db/prisma-relation-mode"/>
        <updated>2024-05-22T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번에는 MySQL 로컬환경에서 PlanetScale 서비스로 넘어가기 위한 설정을 할 때 겪었던 에러에 대해 다루려고 한다.

![VT10001 외래키 제약 에러 발생](https://github.com/Zamoca42/blog/assets/96982072/e0429b8d-12e9-45c8-9625-6d22189d91c1)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Prisma"/>
        <category label="MySQL"/>
        <category label="PlanetScale"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[맛집 목록 가져와서 지도에 표시하기]]></title>
        <id>etc/db/query-range</id>
        <link href="https://zamoca.space/etc/db/query-range"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
공공데이터로 맛집 목록을 받아와서 지도에 내 위치 주변 맛집을 보여주는 API를 만들었습니다.

> 해당 프로젝트 링크: https://github.com/pre-onboarding-backend-G/feed-me-baby

제가 맡은 부분은 전처리된 데이터를 가져와서 맛집 목록을 지도에 표시할 수 있게 반환하는 부분입니다.

여러 방법이 있겠지만 처음에는 맛집 목록을 내 위치 기준으로 범위만큼 위도나 경도를 빼거나 더해서 가져왔습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="PostgreSQL"/>
        <category label="TypeORM"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeORM - DISTINCT]]></title>
        <id>etc/db/typeorm-distinct</id>
        <link href="https://zamoca.space/etc/db/typeorm-distinct"/>
        <updated>2024-01-26T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
TypeORM을 사용해서 개발하다보면 페이지네이션 처리를 해야하는 경우가 생긴다.
이 때 목록 조회 API를 구현하고 요청할 때 SQL문을 보면 SELECT 쿼리에 DISTINCT가 들어있는 경우가 있다.

![유저 목록 조회시 DISTINCT 쿼리가 생기는 것을 볼 수 있다.](https://github.com/Zamoca42/blog/assets/96982072/f109a7a3-0fe3-43da-9d7b-5cc149e79553)

SELECT DISTINCT 쿼리는 왜 생기는지 궁금하여 찾아보다가 나온 정보들을 이번 포스트에서 정리하려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Database"/>
        <category label="TypeORM"/>
        <category label="ORM"/>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL - subquery]]></title>
        <id>etc/db/sql/sql-subquery</id>
        <link href="https://zamoca.space/etc/db/sql/sql-subquery"/>
        <updated>2024-02-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://youtu.be/lwmwlA2WhFc?si=Szgl3bDlly7CF266

서브쿼리(subquery)란 nested query 또는 inner query 라고 불리며
SELECT, INSERT, UPDATE, DELETE 쿼리문에 포함된 쿼리를 말한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 1 ~ 5강]]></title>
        <id>etc/db/sql/sql</id>
        <link href="https://zamoca.space/etc/db/sql/sql"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 1 ~ 5강의 내용입니다

## 데이터 베이스를 조작하는 언어 SQL

- SQL은 '관계형 데이터베이스 관리 시스템(RDBMS)'을 조작할 때 사용한다.

- 관계형 데이터베이스
  - Oracle
  - DB2
  - SQL Server
  - PostgreSQL
  - MySQL
  - SQLite

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 6 ~ 10강]]></title>
        <id>etc/db/sql/sql2</id>
        <link href="https://zamoca.space/etc/db/sql/sql2"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 6 ~ 10강의 내용입니다

## 검색 조건 지정하기

데이터를 검색하는 방법에는 열을 지정하는 방법과 행을 지정하는 방법이 있습니다.

```sql
SELECT 열1, 열2 FROM 테이블명 WHERE 조건식
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 11 ~ 15강]]></title>
        <id>etc/db/sql/sql3</id>
        <link href="https://zamoca.space/etc/db/sql/sql3"/>
        <updated>2023-10-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 11 ~ 15강의 내용입니다

## 결과 행 제한하기

LIMIT 구로 결과 행을 제한하는 방법에 관해 알아보겠습니다.

```sql
SELECT 열명 FROM 테이블명 LIMIT 행수 [OFFSET 시작행]
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[백준 2748 - 피보나치 수]]></title>
        <id>etc/coding-test/boj-2748</id>
        <link href="https://zamoca.space/etc/coding-test/boj-2748"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
피보나치 수를 구할 때 동적계획법을 활용 해보겠습니다.

피보나치 수는 0과 1로 시작합니다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다.
그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 됩니다.

이를 점화식으로 나타내면 $F_n = F_{n-1} + F_{n-2}$ 이고 $n = 17$ 일 때 까지 피보나치 수를 써보면 다음과 같습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Boj"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[성격유형 검사하기 - Python]]></title>
        <id>etc/coding-test/programmers-mbti</id>
        <link href="https://zamoca.space/etc/coding-test/programmers-mbti"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로그래머스 [성격 유형 검사하기][personal] 문제입니다.

문제에서 각 지표는 4개 지표로 나눠집니다.

1. 라이언형(R), 튜브형(T)
2. 콘형(C), 프로도형(F)
3. 제이지형(J), 무지형(M)
4. 어피치형(A), 네오형(N)

예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다.

|   선택지    |            성격 유형 점수             |
| :---------: | :-----------------------------------: |
| 매우 비동의 |              네오형 3점               |
|   비동의    |              네오형 2점               |
| 약간 비동의 |              네오형 1점               |
|  모르겠음   | 어떤 성격 유형도 점수를 얻지 않습니다 |
|  약간 동의  |             어피치형 1점              |
|    동의     |             어피치형 2점              |
|  매우 동의  |             어피치형 3점              |

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Programmers"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[신고 결과 받기 - Python]]></title>
        <id>etc/coding-test/programmers-report</id>
        <link href="https://zamoca.space/etc/coding-test/programmers-report"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로그래머스 [신고 결과 받기][report] 문제입니다

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Programmers"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그 이전 후기]]></title>
        <id>retrospect/blog-migrate</id>
        <link href="https://zamoca.space/retrospect/blog-migrate"/>
        <updated>2023-10-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
처음 vue-django를 이용해서 기술 블로그를 사용하면서 옵시디언으로 글을 작성해서 블로그에 업로드하고
GitHub의 TIL 리포지토리에 쓴 글들을 백업하는 과정이 있었는데 업로드 과정이 비효율적이라는 생각이 들었습니다.
점점 공부한 내용을 기록하고 업로드하는 과정이 즐겁지 않아서 업로드 기간이 늘어나고 점점 글을 쓰지 않게 되었습니다.
그래서 업로드 기간이 늘어난 것에 대해 고민을 하다가 vue-django 블로그를 정리하고 GitHub Pages로 블로그를 변경했습니다.
블로그를 바꾸게된 과정과 생각을 이번 글에서 정리해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 블로그로 이전 후기]]></title>
        <id>retrospect/next-blog-migrate</id>
        <link href="https://zamoca.space/retrospect/next-blog-migrate"/>
        <updated>2024-07-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Vuepress에서 Next.js로 블로그를 이전한 후기입니다.]]></summary>
        <content type="html"><![CDATA[
Vuepress를 이용한 블로그를 사용하다가 여러 가지 문제에 부딪히게 되었다.
처음에는 블로그에 최적화된 레이아웃과 마크다운을 사용하는 것이 편했으나,
의존성 충돌이 빈번하게 일어나고 제한적인 플러그인과 트러블 슈팅에 대한 정보가 부족해 한계를 느껴 Next.js로 변경을 고려하게 되었다.

이번 포스트에서는 Next.js로 블로그를 이전하기까지 과정을 정리하고 공유해보려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[오후스튜디오 회원 관리 페이지 개발 후기]]></title>
        <id>retrospect/ohoo-admin</id>
        <link href="https://zamoca.space/retrospect/ohoo-admin"/>
        <updated>2023-10-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
오후스튜디오에서 일하시는 개발자분과 멘토링하면서 실제 DB테이블을 가지고 회원 관리 페이지를 만들어보자고
제안해주셔서 회원 정보, 요금제 정보를 불러오는 페이지를 만들어봤습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[내가 오픈소스에 기여하게된 이유와 2025년 목표]]></title>
        <id>retrospect/oss-contribution</id>
        <link href="https://zamoca.space/retrospect/oss-contribution"/>
        <updated>2025-02-02T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Open-Source"/>
        <category label="Career"/>
        <category label="Growth"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 파일 미리보기 기여 후기]]></title>
        <id>retrospect/oss-gitbutler-binary</id>
        <link href="https://zamoca.space/retrospect/oss-gitbutler-binary"/>
        <updated>2024-10-21T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 관련 이슈 1: https://github.com/gitbutlerapp/gitbutler/issues/2752  
> 관련 이슈 2: https://github.com/gitbutlerapp/gitbutler/issues/3093

이번 후기는 GitButler에서 바이너리 파일(이미지, 폰트파일 등)을 미리보기 기능을 구현한 것에 대한 후기이다.

![UI에서 미리보기 없이 Binary content not shown을 출력한다](https://github.com/user-attachments/assets/bc6269bd-14c0-4874-afc5-526d8ca82dfa)

관련 이슈를 살펴보면 바이너리 파일을 미리보기 기능을 구현하는 것에 대한 이슈가 있었다.  
UI에서 이미지는 미리보기 기능, 이미지 외의 파일에 대한 사이즈 정보를 보여주는 기능을 구현하는 것이 목표였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="GitButler"/>
        <category label="Git"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 리눅스 환경에서 실행시 창이 꺼지는 문제 기여 후기]]></title>
        <id>retrospect/oss-gitbutler-linux-window</id>
        <link href="https://zamoca.space/retrospect/oss-gitbutler-linux-window"/>
        <updated>2024-10-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 해당 이슈: https://github.com/gitbutlerapp/gitbutler/issues/4039

GitButler를 살펴보다 발견한 이슈는 리눅스 환경에서 최대화를 시도하면 창이 자동으로 꺼지는 문제였다.

링크에서 이슈를 살펴보면 Tauri의 window-state와 관련이 있는거 같긴 했지만 Tauri와 의존된 부분이 많아서 정확히 부분을 찾아야했다.

helpwanted 라벨이 달려있어서 해당 이슈에 기여해보고 싶어졌다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="GitButler"/>
        <category label="Linux"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tauri - 리눅스 환경에서 실행시 창이 꺼지는 문제 기여 후기 2]]></title>
        <id>retrospect/oss-tauri-tao</id>
        <link href="https://zamoca.space/retrospect/oss-tauri-tao"/>
        <updated>2024-10-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> [이전 포스트](https://zamoca.space/etc/retrospect/oss-gitbutler-linux-window)에서 이어지는 내용입니다.  
> 해당 이슈: https://github.com/tauri-apps/tao/issues/977

처음에는 linux에서 `Error 71 (Protocol error) dispatching to Wayland display.`가 발생하는 이유는
Tauri의 window-state 플러그인의 자체적인 문제라고 생각했다.

그래서 Tauri의 플러그인 레포지토리에 [이슈](https://github.com/tauri-apps/plugins-workspace/issues/1779)를 남겼지만
창이 최대화시에 발생하는 문제라면 Tauri의 업스트림 중 하나인 Tao에서 발생하는 문제라고 답변을 들을 수 있었다.

![타우리의 아키텍쳐](https://github.com/user-attachments/assets/cc83e09a-0ad6-4da6-9e25-bd812079a2ec)

Tao는 Tauri에서 창을 생성하고 관리하는 라이브러리이다.

그래서 이슈를 Tao에서 다시 작성한 후에 Discord에 메인테이너에게 기여를 해도되는지 문의를 했고
메인테이너에게 자유롭게 기여를 해도된다는 답변을 받았다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Tauri"/>
        <category label="Linux"/>
        <category label="Open-Source"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-django 블로그 개발 후기]]></title>
        <id>retrospect/vue-django-blog</id>
        <link href="https://zamoca.space/retrospect/vue-django-blog"/>
        <updated>2023-10-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
로봇공학, 인공지능 강의를 들으면서 파이썬에 관심을 가지게 되었고 파이썬으로 공부를 하면서 배운 것을 어떻게 적용해볼 수 있을지 고민했습니다.
마침 인프런에서 vue-django 블로그 만들기가 눈에 들어왔고 만들어서 기술블로그로 사용할 생각으로 AWS에 배포까지 계획했습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Retrospect"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Auth.js로 알아보는 세션과 JWT 인증 방식의 차이]]></title>
        <id>js-ts/auth-js</id>
        <link href="https://zamoca.space/js-ts/auth-js"/>
        <updated>2024-08-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Auth.js를 활용하여 개발하면서 세션(Session)과 JWT(JSON Web Token) 인증 방식에 대해 실제로 경험해 볼 수 있었다.
두 방식 모두 쿠키를 사용하기에 각 방식의 특징과 사용 경험을 중심으로 정리해 보았다.

## Auth.js 소개

> 🌐 https://authjs.dev/getting-started

Auth.js는 인증을 쉽게 구현할 수 있게 해주는 강력한 라이브러리다.  
Google 로그인과 같은 OAuth나 이메일 인증 로그인을 지원하며, 세션 및 JWT 기반의 인증을 모두 구현할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JWT"/>
        <category label="Session"/>
        <category label="Next.js"/>
        <category label="Auth.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[date-fns로 Date 객체 다루기]]></title>
        <id>js-ts/date-fns</id>
        <link href="https://zamoca.space/js-ts/date-fns"/>
        <updated>2024-04-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
TODO 앱을 직접 만들어보면서 오늘 날짜를 기준으로 완료 여부를 확인할 수 있는 기능을 만들어보기 위해

date-fns 라이브러리를 사용했다.

## startOfDay, endOfDay

date-fns의 startOfDay와 endOfDay 함수를 사용하면 Date 객체 기준

날짜의 시작 시간과 완료 시간을 보여주는데

오늘의 범위를 0시부터 23시 59분 기준으로 생각하고 함수를 사용하면 생각과 다른 결과가 나온다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="TypeScript"/>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js로 디렉토리 트리 탐색하기]]></title>
        <id>js-ts/node-readdir</id>
        <link href="https://zamoca.space/js-ts/node-readdir"/>
        <updated>2024-06-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[fs.readdir의 recursive 옵션으로 모든 마크다운 파일 찾기]]></summary>
        <content type="html"><![CDATA[
Next.js 블로그 스타터를 시작하면 마크다운 포스트를 가져오는 로직은 `fs.readFileSync()`를 사용하여 컨텐츠 폴더 아래의 파일만 탐색하게 된다.

```ts:lib/api.ts {15}
import { Post } from "@/interfaces/post";
import fs from "fs";
import matter from "gray-matter";
import { join } from "path";

const postsDirectory = join(process.cwd(), "_posts");

export function getPostSlugs() {
  return fs.readdirSync(postsDirectory);
}

export function getPostBySlug(slug: string) {
  const realSlug = slug.replace(/\.md$/, "");
  const fullPath = join(postsDirectory, `${realSlug}.md`);
  const fileContents = fs.readFileSync(fullPath, "utf8");
  const { data, content } = matter(fileContents);

  return { ...data, slug: realSlug, content } as Post;
}
//...
```

하지만 컨텐츠 폴더 내부에 하위 폴더가 존재하면 해당 폴더 내의 파일은 찾지 못하는 문제가 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node.js"/>
        <category label="TypeScript"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[사이드바 정렬 개선하기]]></title>
        <id>js-ts/sidebar-sorting</id>
        <link href="https://zamoca.space/js-ts/sidebar-sorting"/>
        <updated>2024-06-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[폴더, 파일을 문자열 정렬에서 개선해보자]]></summary>
        <content type="html"><![CDATA[
블로그의 사이드바에서 현재 포스트가 가지고 있는 카테고리 폴더와 파일을 보여주려고 컴포넌트를 만들었는데,
정렬 방식이 마음에 들지 않았다.

이를 개선하기 위해 두 가지 목표를 설정했다.

1. 숫자를 포함한 정렬 방식으로 변경
2. 폴더를 파일보다 상위에 배치

![자바스크립트 문자열 방식으로 정렬하고 폴더와 파일의 순서에 구분이 없었다.](https://github.com/Zamoca42/next-blog/assets/96982072/3743a624-545c-48c5-b341-342a722d8a97)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node.js"/>
        <category label="TypeScript"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그에 검색 적용하기 - Docsearch]]></title>
        <id>js-ts/next/blog-docsearch</id>
        <link href="https://zamoca.space/js-ts/next/blog-docsearch"/>
        <updated>2024-07-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
블로그에 검색 기능이 없어서 한글 형태소 지원, 적은 비용, 쉬운 유지보수를 고려한 라이브러리 사용을 고민하다 Typesense와 Aloglia를 알게 되었다.

Algolia는 Vuepress나 공식문서 페이지에서 자주 볼 수 있었는데,
한글 형태소 검색이 지원되고 프리티어로 한달에 요청횟수 10k, 지원 문서 수 100만개까지 적용되어서 사용해봤다.

이번 포스트에서는 Next.js에서 문서 검색을 설정한 과정에서 겪은 일들을 정리하려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Aloglia"/>
        <category label="Next.js"/>
        <category label="TypeScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 14 - HotReload 에러]]></title>
        <id>js-ts/next/hot-reload</id>
        <link href="https://zamoca.space/js-ts/next/hot-reload"/>
        <updated>2024-06-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
NextJS로 프로젝트를 진행하던 중에 [Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)
를 설정해 모달창을 구현하다가 HotReload 에러를 만나게 되었다.

![내가 겪은 에러와 완전히 같아서 참고링크의 사진을 첨부했다.](https://github.com/Zamoca42/blog/assets/96982072/9df58ab8-0822-4079-8e18-072df747b9fd)

Next로 모달을 구현하게되면 Parallel Routes를 자주 사용하게 될텐데 같은 에러가 생기면 다시 해결하기 위해 기록으로 남겨두려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="TypeScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js 14 - Lighthouse로 웹페이지 성능 개선하기]]></title>
        <id>js-ts/next/lighthouse</id>
        <link href="https://zamoca.space/js-ts/next/lighthouse"/>
        <updated>2024-07-31T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Next.js 14 정적 블로그에서 성능 개선을 시도한 경험을 이번 포스트에서 정리하려고 한다.
처음에는 웹 성능 측정 도구에 대해 잘 몰라 어떤 지표로 성능을 평가해야 할지 막막했다.

## Lighthouse 도구 발견

![초기 성능 진단 결과](https://github.com/user-attachments/assets/dbea020e-29f7-4ff0-9ccb-d1b175dd4716)

웹 성능 최적화에 대해 검색하던 중 Google에서 제공하는 Lighthouse라는 도구를 알게 되었다.
Lighthouse는 웹페이지의 성능, 접근성, SEO 등 다양한 측면을 분석해주는 강력한 도구였다.

![초기 진단 항목들 중 LCP와 FCP에 영향을 주는 항목이 눈에 띈다.](https://github.com/user-attachments/assets/2bdd2c27-9fe1-448b-a16f-346680ecf0a7)

프로덕션 환경에서 실행 결과, Largest Contentful Paint(LCP)이 눈에 띄는데  
진단 항목을 살펴보면 이미지가 주된 원인이였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Lighthouse"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[마크다운 플러그인 세팅]]></title>
        <id>js-ts/next/markdown-plugin</id>
        <link href="https://zamoca.space/js-ts/next/markdown-plugin"/>
        <updated>2024-07-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[마크다운 플러그인인 remark, rehype와 react-markdown에 대해 알아보자]]></summary>
        <content type="html"><![CDATA[
정적 블로그를 만들 때 마크다운 파일을 사용하는 경우, 단순히 `<div>` 태그와 `dangerouslySetInnerHTML` 속성으로 정적 콘텐츠를 삽입할 수 있다.

하지만 이 방법으로는 추가적인 커스터마이징이 어렵다.

이를 해결하기 위해 `next-mdx-remote`와 같은 라이브러리와 `remark` 같은 플러그인을 사용하면 HTML 코드를 원하는 대로 수정할 수 있다.

Next.js 공식 문서에서는 MDX를 이용한 정적 블로그 예시를 제공하고 있다.
하지만 이미 마크다운 형식으로 포스트를 작성해왔기 때문에 MDX로 변환할 필요성을 느끼지 못했다. `next-mdx-remote`에서 옵션으로 `.md` format을 지원하지만
설정하는 방법이 직관적이라는 생각이 들지 않아서 [react-markdown](https://github.com/remarkjs/react-markdown)
을 사용하기로 결정했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="React"/>
        <category label="Markdown"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Auth.js v4 - Unknown arg `access_token`... 에러]]></title>
        <id>js-ts/next/prisma-token-schema-error</id>
        <link href="https://zamoca.space/js-ts/next/prisma-token-schema-error"/>
        <updated>2024-06-13T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Auth.js는 NextJS 친화적으로 설계된 오픈소스 인증 라이브러리다.

NextJS에서 간단한 설정만으로 OAuth나 이메일 인증 로직을 적용할 수 있어 편리하다.

다만 커스터마이징을 하기에는 사용자가 내부로직을 알기 모호하고 문서가 복잡하고 불친절하다는 느낌을 받았다.

그 예로 NextJS에서 Prisma를 이용해 구글 이메일 로그인을 구현하면서 겪은 에러에 대해 정리하려고 한다.

해당 내용은 Auth.js v4에서 겪은 에러로 내용은 다음과 같다.

```txt:에러내용
Unknown arg `access_token` in data.access_token for type AccountUncheckedCreateInput. Did you mean `accessToken`?
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Auth.js"/>
        <category label="Prisma"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js - 빌드 타임에 스크립트를 실행하는 방법]]></title>
        <id>js-ts/next/run-script-build-time</id>
        <link href="https://zamoca.space/js-ts/next/run-script-build-time"/>
        <updated>2024-06-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[What's the recommended way to run a script at build time?]]></summary>
        <content type="html"><![CDATA[
마크다운 컨텐츠를 활용한 블로그를 만들면서 포스트의 생성일과 수정일을 커밋 날짜를 기준으로 블로그에 보여주려고 했다.

git 명령어를 [node.js의 child_process](https://www.freecodecamp.org/korean/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/)
로 실행하면서 개발서버에서는 이상없이 돌아갔으나...

Vercel에 배포 할때는 `.git` 레포지토리가 포함되지 않기 때문에 git 명령어를 사용할 수 없다고 한다.

![vercel command failed](https://github.com/Zamoca42/blog/assets/96982072/4cdbfb40-d459-424a-966b-4794e5b13f90)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Next.js"/>
        <category label="Node"/>
        <category label="Script"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next.js - SEO와 검색엔진 등록]]></title>
        <id>js-ts/next/seo</id>
        <link href="https://zamoca.space/js-ts/next/seo"/>
        <updated>2024-07-24T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
구글과 네이버 같은 검색엔진은 크롤링 봇이 있는데 크롤링 봇이 웹사이트와 웹페이지를 수집하고 등록시켜 검색하는 유저에게 노출한다.
SEO(Search Engine Optimization)는 검색엔진 크롤링 봇에게 내 웹페이지를 수집하기 쉽도록 개선하는 작업을 말한다.  
SEO를 직접 제공하는 블로그 서비스를 이용하는 것이 아닌 이상 자동으로 검색엔진에 등록되는일은 없으므로 SEO를 위한 작업이 필요하다.

Next.js 14버전의 App router를 기준으로 진행한 SEO 작업들을 정리하려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SEO"/>
        <category label="Next.js"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[고객정보 API 만들기]]></title>
        <id>js-ts/nest-js/api</id>
        <link href="https://zamoca.space/js-ts/nest-js/api"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![회원 정보 검색](https://github.com/Zamoca42/blog/assets/96982072/3cb4e5b5-b460-470e-8c80-f65a1502ed44)

이렇게 클라이언트에서 회원아이디를 입력했을때 회원의 정보를 보여주려고합니다

```json
{
  "id": "sdfsdf333",
  "phoneNumber": "+821099990001",
  "email": "이메일@.com",
  "businessName": "회사이름",
  "businessItem": "사업"
}
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Project"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[응답 객체 직렬화하기]]></title>
        <id>js-ts/nest-js/class-transformer</id>
        <link href="https://zamoca.space/js-ts/nest-js/class-transformer"/>
        <updated>2023-12-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
요청 객체를 역직렬화 과정과 마찬가지로 클라이언트에 데이터를 전달할 때
응답 객체를 인스턴스로 변환하는데 NestJS에서는 `class-transformer`를 사용한다.

한 객체가 변경이 발생하면 해당 객체에 의존하는 다른 객체들도 변경해야 하기 때문에 이들의 변경 범위를 최소화 하기 위해 캡슐화를 사용한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Class-Transformer"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[요청 객체 역직렬화하기]]></title>
        <id>js-ts/nest-js/class-validator</id>
        <link href="https://zamoca.space/js-ts/nest-js/class-validator"/>
        <updated>2023-12-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
클라이언트에서 HTTP 요청시 JSON이나 쿼리스트링의 경우 클래스 인스턴스로 변환하는 역직렬화와 유효성 검사과정이 필요하다.

이 부분은 `class-validator` 패키지가 필요하다.
[`class-validator`][class-validator]는 데코레이터를 기반으로 Dto들의 검증을 담당한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Class-Validator"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Custom validation 만들기]]></title>
        <id>js-ts/nest-js/custom-validator</id>
        <link href="https://zamoca.space/js-ts/nest-js/custom-validator"/>
        <updated>2023-11-07T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
위도, 경도에 대한 범위를 넣어서 검증하는 validator를 만들어 보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DTO (Data Transfer Object)]]></title>
        <id>js-ts/nest-js/dto</id>
        <link href="https://zamoca.space/js-ts/nest-js/dto"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## DTO란?

DTO(Data Transfer Object)는 **계층간 데이터 교환**을 하기 위해 사용하는 객체로
로직을 가지지 않은 객체이고 getter, setter 메서드만 가진 클래스를 의미합니다.

![Layered 아키텍쳐](https://github.com/Zamoca42/blog/assets/96982072/9460d59f-2b48-445c-85ca-23f9b7021520)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[sh 1 nest not found 오류]]></title>
        <id>js-ts/nest-js/error-cli-not-found</id>
        <link href="https://zamoca.space/js-ts/nest-js/error-cli-not-found"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
도커를 이미지화 하거나 배포시 인스턴스에서 `sh: 1: nest: not found`를 자주 보게 되는데
왜 이런 오류가 발생하는지 어떻게 해결했는지 포스트로 기록한다.

![Render로 배포시 발생한 not found 오류](https://github.com/develop-pix/dump-in-Admin-BE/assets/96982072/bf72345c-c77e-48b3-a173-41d3a702ca19)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Error"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[전역으로 예외 처리 적용하기]]></title>
        <id>js-ts/nest-js/error-exception</id>
        <link href="https://zamoca.space/js-ts/nest-js/error-exception"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Nest에는 애플리케이션 전체에서 처리되지 않은 모든 예외를 처리하는 예외 계층(Exceptions Layer)이 내장되어 있습니다.
애플리케이션 코드에서 예외가 처리되지 않으면 이 계층에서 이를 포착한 다음 사용자에게 응답을 내보냅니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[서비스 레이어에서 예외처리 분리하기]]></title>
        <id>js-ts/nest-js/exception</id>
        <link href="https://zamoca.space/js-ts/nest-js/exception"/>
        <updated>2024-01-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
서비스 레이어에서 예외처리를 하고있었는데 [좋은 예외(Exception) 처리][exception-blog]에서
글을 보고 의문이 들어 리팩터링을 진행했는데 포스트로 정리하려고한다.
소제목 파트인 정상적인 흐름에서 Catch 금지, Layer에 맞는 예외 보고 의문이 들기 시작했다.

![어디서 많이 본 로직이 보였다.](https://github.com/develop-pix/dump-in-Admin-BE/assets/96982072/ef451050-bdfe-4e59-a4c1-7030c6f181aa)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="TypeORM"/>
        <category label="Error"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[외부 로거로 효율적으로 모니터링하기]]></title>
        <id>js-ts/nest-js/external-logger</id>
        <link href="https://zamoca.space/js-ts/nest-js/external-logger"/>
        <updated>2023-12-27T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
로컬에서는 에러가 발생했을 때 터미널에서 로그메세지를 확인할 수 있지만 배포환경에서는 로그를 남겨야 어떤 문제가 발생했는지 알 수 있다.

처음에는 모든 로그를 남겨서 확인하려고했으나 로그를 찾아서 확인하는 것도 번거로운 일이였다.
그래서 예상할 수 있는 예외는 제외하고 심각한 로그를 구분해서 알림을 만드는 것이 필요했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Winston"/>
        <category label="Sentry"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[프로젝트 시작하기]]></title>
        <id>js-ts/nest-js/introduction</id>
        <link href="https://zamoca.space/js-ts/nest-js/introduction"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 소개

Nest(NestJS)는 Node.js에 기반한 프레임워크로 Express나 Fastify를 사용하여 동작합니다

#### with Express (default)

```typescript
import * as session from "express-session";

// somewhere in your initialization file
app.use(
  session({
    secret: "my-secret",
    resave: false,
    saveUninitialized: false,
  })
);
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[로그인 구현하기]]></title>
        <id>js-ts/nest-js/login-module</id>
        <link href="https://zamoca.space/js-ts/nest-js/login-module"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
React Admin에서 로그인 페이지를 만들고 Nest의 인증 모듈과 연결했을 때의 화면입니다.

![로그인 화면](https://github.com/Zamoca42/blog/assets/96982072/9218fafc-bc81-4780-b22b-4274e3f3ec6b)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[API 요청 시도 횟수 제한하기]]></title>
        <id>js-ts/nest-js/rate-limit</id>
        <link href="https://zamoca.space/js-ts/nest-js/rate-limit"/>
        <updated>2023-12-15T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
외부에서 로그인 시도할 때 횟수에 제약이 없다는 것은 무작위 반복해서 아이디와 비밀번호를 대입해도 막을 방법이 없다.
이를 막을 방법에는 세션에 로그인 시도를 기록하는 방법이 있고, 일정 로그인 횟수 이상으로 시도시 ip를 차단하는 방법도 있을 것이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Express"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[서버 상태 모니터링하기]]></title>
        <id>js-ts/nest-js/server-monitoring</id>
        <link href="https://zamoca.space/js-ts/nest-js/server-monitoring"/>
        <updated>2023-12-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
[외부 로거 도입](./external-logger.md)해서 Sentry로 error 레벨의 로그를 알림을 받도록 했었다.
Sentry의 기능 중에 크론 모니터링 기능이 있어서 NestJS가 지원하는 스케쥴러로 주기적으로 서버 상태를 모니터링하려고 했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Sentry"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[세션 쿠키 인증/인가]]></title>
        <id>js-ts/nest-js/session</id>
        <link href="https://zamoca.space/js-ts/nest-js/session"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
NestJS에서 [express-session][express-session]으로 세션 인증을 구현해보면서 알게된 점을 정리해보려고 합니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Express"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[스택 트레이스로 에러 추적하기]]></title>
        <id>js-ts/nest-js/stack-trace</id>
        <link href="https://zamoca.space/js-ts/nest-js/stack-trace"/>
        <updated>2023-11-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
기존의 예외 처리 설정에서는 BadRequestException이 발생하면
오류가 발생한 url이나 메세지 정도는 보여줬지만, 정확한 위치나 내용은 알 수 없었습니다.

스택 트레이스를 넣어보면서 에러의 위치나 내용을 자세히 넣는 기능을 넣어보고
내장 로거대신 winston 로거 설정을 추가해서 읽기 좋은 로거를 만들어 보려고 합니다.

## 스택 트레이스란?

스택 트레이스는 예외가 어디에서 발생했는지, 어떤 함수 호출 순서가 예외를 유발했는지 등을
나타내는 정보를 로그에 추가해 디버깅 및 예외 추적 시 도움이 됩니다.

NestJS에서는 Error 객체에 stack 프로퍼티를 사용해서 스택 트레이스를 볼 수 있습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Winston"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stub을 이용한 단위 테스트 적용하기]]></title>
        <id>js-ts/nest-js/unit-test</id>
        <link href="https://zamoca.space/js-ts/nest-js/unit-test"/>
        <updated>2023-12-27T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="Test"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[10. 객체 리터럴]]></title>
        <id>js-ts/deepdive/deepdive10</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive10"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 객체란?

자바스크립트는 객체 기반의 프로그래밍 언어이며, 원시 값을 제외한 나머지 값은 모두 객체다.
원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체는 변경 가능한 값(mutable value)이다.

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.

![10-1](https://github.com/Zamoca42/blog/assets/96982072/30727ee8-b9c9-4c6a-b5e7-a974189d3cca)

프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다.

![10-2](https://github.com/Zamoca42/blog/assets/96982072/e9dd00c6-7cec-481e-aa6e-3a8bf9d935da)

프로퍼티와 메서드의 역할은 다음과 같다

- 프로퍼티: 객체의 상태를 나타내는 값(data)
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

이처럼 객체는 객체의 상태를 나타내는 값과 프로퍼티를 참조하고 조작할 수 있는 메서드를
모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.

![10-3](https://github.com/Zamoca42/blog/assets/96982072/59e3746c-4e49-44b9-9eb5-3a45167f4e8b)

객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 객체지향 프로그래밍이라 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[11. 원시 값과 객체의 비교]]></title>
        <id>js-ts/deepdive/deepdive11</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive11"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트에서 값은 크게 원시 타입과 객체 타입으로 구분할 수 있다.

- **원시 타입**의 값은 변경 불가능한 값이며, 변수에 할당될 때 **값에 의한 전달**로 동작한다.
- **객체 타입**의 값은 변경 가능한 값이며, 변수에 할당될 때 **참조에 의한 전달**로 동작한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[12. 함수]]></title>
        <id>js-ts/deepdive/deepdive12</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive12"/>
        <updated>2023-09-29T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 함수란?

함수는 자바스크립트에서 가장 중요한 핵심 개념이다.
또 다른 자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[13. 스코프]]></title>
        <id>js-ts/deepdive/deepdive13</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive13"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 스코프란?

스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다.

스코프는 변수와 함수의 유효한 범위를 나타낸다.

```js
function add(x, y) {
  console.log(x, y);
  return x + y;
}

add(2, 5);

// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x, y); // ReferenceError
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[14. 전역 변수의 문제점]]></title>
        <id>js-ts/deepdive/deepdive14</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive14"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
전역 변수의 무분별한 사용은 위험하다.

전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다.

이번 장에서는 전역 변수의 문제점과 전역 변수의 사용을 억제할 수 있는 방법을 살펴보자.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[15. let, const 키워드와 블록 레벨 스코프]]></title>
        <id>js-ts/deepdive/deepdive15</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive15"/>
        <updated>2023-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. var 키워드로 선언한 변수의 문제점

ES5까지 변수를 선언할 수 있는 유일한 방법은 `var` 키워드를 사용하는 것이었다.  
var 키워드로 선언된 변수는 다음과 같은 특징이 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[16. 프로퍼티 어트리뷰트]]></title>
        <id>js-ts/deepdive/deepdive16</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive16"/>
        <updated>2023-10-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 내부 슬롯과 내부 메서드

내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다.

ECMAScript 사양에 등장하는 이중 대괄호(`[[...]]`)으로 감싼 이름들이 내부 슬롯과 내부 메서드다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[17. 생성자 함수에 의한 객체 생성]]></title>
        <id>js-ts/deepdive/deepdive17</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive17"/>
        <updated>2023-10-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번 장에서는 생성자 함수를 사용하여 객체를 생성하는 방식을 살펴보고, 객체 리터럴을 사용하여 객체를 생성하는 방식과의 장단점을 비교해보자.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[18. 함수와 일급 객체]]></title>
        <id>js-ts/deepdive/deepdive18</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive18"/>
        <updated>2023-10-04T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 일급 객체

자바스크립트의 함수는 다음 조건을 모두 만족하는 **일급 객체**다.

1. 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[19. 프로토타입]]></title>
        <id>js-ts/deepdive/deepdive19</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive19"/>
        <updated>2023-10-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트는 프로토타입을 기반으로 상속을 구현하여 객체 지향 프로그래밍 능력을 지니고 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[20. strict mode]]></title>
        <id>js-ts/deepdive/deepdive20</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive20"/>
        <updated>2023-10-11T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. strict mode란?

strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나
자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

예를 들어, 선언하지 않은 변수를 참조하면 암묵적으로 전역 변수가 생성되는 현상(암묵적 전역)은 오류를 발생시키는 원인이 될 수 있다. strict mode에서는 이를 에러로 인식한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[21. 빌트인 객체]]></title>
        <id>js-ts/deepdive/deepdive21</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive21"/>
        <updated>2023-10-12T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[22. this]]></title>
        <id>js-ts/deepdive/deepdive22</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive22"/>
        <updated>2023-10-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. this 키워드

메서드에서 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 사용해야 한다.  
이때 사용되는 것이 this 키워드다.

```js
const circle = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  },
};

console.log(circle.getDiameter()); // 10
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[23. 실행 컨텍스트]]></title>
        <id>js-ts/deepdive/deepdive23</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive23"/>
        <updated>2023-10-15T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[24. 클로저]]></title>
        <id>js-ts/deepdive/deepdive24</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive24"/>
        <updated>2023-10-18T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[25. 클래스]]></title>
        <id>js-ts/deepdive/deepdive25</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive25"/>
        <updated>2023-10-23T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[26. ES6 함수의 추가 기능]]></title>
        <id>js-ts/deepdive/deepdive26</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive26"/>
        <updated>2023-10-29T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[27. 배열]]></title>
        <id>js-ts/deepdive/deepdive27</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive27"/>
        <updated>2023-10-30T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[34. 이터러블]]></title>
        <id>js-ts/deepdive/deepdive34</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive34"/>
        <updated>2023-11-09T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[35. 스프레드 문법]]></title>
        <id>js-ts/deepdive/deepdive35</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive35"/>
        <updated>2023-11-12T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[36. 디스트럭처링 할당]]></title>
        <id>js-ts/deepdive/deepdive36</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive36"/>
        <updated>2023-11-13T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[37. Set과 Map]]></title>
        <id>js-ts/deepdive/deepdive37</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive37"/>
        <updated>2023-11-15T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[38. 브라우저의 렌더링 과정]]></title>
        <id>js-ts/deepdive/deepdive38</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive38"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[39. DOM]]></title>
        <id>js-ts/deepdive/deepdive39</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive39"/>
        <updated>2023-11-05T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[4. 변수]]></title>
        <id>js-ts/deepdive/deepdive4</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive4"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 변수란 무엇인가?

- 컴퓨터는 데이터를 메모리에 저장하거나 읽어들임

  - 메모리는 메모리 셀의 집합체

  - 각 셀은 고유의 메모리 주소를 갖는다

    - 4GB 메모리의 주소는 0x00000000 ~ 0xffffffff

- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름

  - 변수에 값을 저장하는 것을 **할당(대입, 저장)**

  - 변수에 저장된 값을 읽어 들이는 것을 **참조**

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[40. 이벤트]]></title>
        <id>js-ts/deepdive/deepdive40</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive40"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 이벤트 드리븐 프로그래밍

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.
예를 들어, 클릭, 키보드 입력, 마우스 이동 등이 일어나면 브라우저는 이를 감지하여 특정한 타입의 이벤트를 발생시킨다.

이벤트가 발생했을 때 호출될 함수를 이벤트 핸들러라 하고,
이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다.

브라우저는 사용자 버튼 클릭을 감지하여 클릭 이벤트를 발생시킬 수 있다.
그리고 특정 버튼 요소에서 클릭 이벤트가 발생하면 이벤트 핸들러를 호출하도록 브라우저에게 위임할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[41. 타이머]]></title>
        <id>js-ts/deepdive/deepdive41</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive41"/>
        <updated>2023-11-20T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[42. 비동기 프로그래밍]]></title>
        <id>js-ts/deepdive/deepdive42</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive42"/>
        <updated>2023-11-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트는 함수를 호출하면 실행 컨텍스트 스택에 푸시되고 순차적으로 함수 코드가 실행된다.

![그림 42-1. 실행 컨텍스트 스택](https://github.com/Zamoca42/blog/assets/96982072/fa7ba17d-3430-4ecd-9858-118ddadd6453)

자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작하기 때문에
처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹이 발생한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[43. Ajax]]></title>
        <id>js-ts/deepdive/deepdive43</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive43"/>
        <updated>2023-11-21T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[45. 프로미스]]></title>
        <id>js-ts/deepdive/deepdive45</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive45"/>
        <updated>2023-11-22T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[46. 제너레이터와 async/await]]></title>
        <id>js-ts/deepdive/deepdive46</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive46"/>
        <updated>2023-11-23T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[47. 에러처리]]></title>
        <id>js-ts/deepdive/deepdive47</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive47"/>
        <updated>2023-11-25T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[48. 모듈]]></title>
        <id>js-ts/deepdive/deepdive48</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive48"/>
        <updated>2023-11-26T00:00:00.000Z</updated>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[5. 표현식과 문]]></title>
        <id>js-ts/deepdive/deepdive5</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive5"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 값

값(value)는 표현식(expression)이 평가되어 생성된 결과를 말한다.

```javascript
// 10 + 20은 평가되어 숫자 값 30을 생성
10 + 20; // 30
```

변수는 **하나의 값**을 저장하기 위해 확보한 메모리 공간

```javascript
var sum = 10 + 20;
```

sum변수에 할당되는 것은 10 + 20이 아니라 30이라는 값이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[6. 데이터 타입]]></title>
        <id>js-ts/deepdive/deepdive6</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive6"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
자바스크립트의 모든 값은 데이터 타입을 갖는다.
데이터 타입(Data type)은 값의 종류를 말한다.

자바스크립트(ES6)은 7개의 데이터 타입을 제공하고
원시 타입(Primitive type)과 객체 타입(Object type)으로 분류할 수 있다.

<table>
  <tr>
    <th>구분</th>
    <th>데이터 타입</th>
    <th>설명</th>
  </tr>
  <tr>
    <td rowspan="6">원시 타입</td>
    <td>숫자(number)</td>
    <td>정수와 실수 구분 없이 하나의 숫자 타입만 존재</td>
  </tr>
  <tr>
    <td>문자열(string)</td>
    <td>문자열</td>
  </tr>
  <tr>
    <td>불리언(boolean)</td>
    <td>논리적 참(true)과 거짓(false)</td>
  </tr>
  <tr>
    <td>undefined</td>
    <td>var 키워드로 선언된 변수에 암묵적으로 할당되는 값</td>
  </tr>
  <tr>
    <td>null</td>
    <td>값이 없다는 것을 의도적으로 명시할 때 사용하는 값</td>
  </tr>
  <tr>
    <td>심벌(symbol)</td>
    <td>ES6에서 추가된 7번째 타입</td>
  </tr>
  <tr>
    <td colspan="2">객체 타입</td>
    <td>객체, 함수, 배열 등</td>
  </tr>
</table>

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. 연산자]]></title>
        <id>js-ts/deepdive/deepdive7</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive7"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
연산자(Operator)는 하나 이상의 표현식을 대상으로, 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

이때 연산의 대상을 피연산자(Operand)라 한다.

```javascript
// 산술 연산자
5 * 4; // -> 20

// 문자열 연결 연산자
"My name is " + "Lee"; // -> 'My name is Lee'

// 할당 연산자
color = "red"; // -> 'red'

// 비교 연산자
3 > 5; // -> false

// 논리 연산자
true && false; //-> false

// 타입 연산자
typeof "Hi"; //-> string
```

연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. 제어문]]></title>
        <id>js-ts/deepdive/deepdive8</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive8"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
제어문은 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다.
일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.
제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.

## 1. 블록문

블록문(block statement)는 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라 부르기도 한다.

```javascript
// 블록문
{
  var foo = 10;
}

// 제어문
var x = 1;

if (x < 10) {
  x++;
}

// 함수 선언문
function sum(a, b) {
  return a + b;
}
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[9. 타입 변환과 단축 평가]]></title>
        <id>js-ts/deepdive/deepdive9</id>
        <link href="https://zamoca.space/js-ts/deepdive/deepdive9"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 1. 타입 변환이란?

개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적(Explicit) 타입 변환**
또는 **타입 캐스팅**이라 한다

```js
var x = 10;

var str = x.toString();
console.log(typeof str, str); // string 10

console.log(typeof x, x); //number 10
```

개발자의 의도와는 상관 없이 표현식을 평가하는 도중에 암묵적으로 타입이 자동 변환 되기도 한다.

이를 **암묵적(Implicit) 타입 변환** 또는 **타입 강제 변환**이라 한다.

```js
var x = 10;

var str = x + "";
console.log(typeof str, str); //string 10

console.log(typeof x, x); //number 10
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="JavaScript"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitButler - 페어소스 기반의 Git 버전 관리 자동화 툴]]></title>
        <id>etc/git-butler</id>
        <link href="https://zamoca.space/etc/git-butler"/>
        <updated>2024-10-18T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://news.hada.io/topic?id=16281

## GitButler 소개

GitButler를 처음 설치하고 실행했을 때는 Source Tree와 Git Desktop, AI를 합쳐놓은 듯한 소프트웨어같은 느낌을 받았다.

흔히 CLI를 통해 git 명령어를 입력하는 것과 달리 GUI로 좀 더 쉽게 버전 관리를 할 수 있도록 도와준다.

직접 사용해보면서 느낀점은 AI를 통해 커밋 메시지를 자동으로 생성해주는 것이 아주 편리하다는 점이였다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="AI"/>
        <category label="Architecture"/>
        <category label="Rust"/>
        <category label="Svelte"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git-flow]]></title>
        <id>etc/git-flow</id>
        <link href="https://zamoca.space/etc/git-flow"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![git flow](https://user-images.githubusercontent.com/96982072/227922966-e7f04bb8-7943-434b-8a8a-cbb4097a0339.png)

git-flow는 브랜치를 5가지 종류로 구분하여 개발하는 전략이다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="Strategy"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub-flow]]></title>
        <id>etc/github-flow</id>
        <link href="https://zamoca.space/etc/github-flow"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
![GitHub-flow](https://user-images.githubusercontent.com/96982072/227937502-73a8e6cd-1c9d-4a9f-93b0-0141d95f06c6.png)

## GitHub-flow의 브랜칭 전략

- 수시로 배포가 일어나며, CI와 배포가 자동화된 프로젝트
- Release Branch가 명확하게 구분되지 않은 시스템
- Pull Request 기능을 사용

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <category label="Strategy"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[VSCode - 커스텀 스니펫과 키 바인딩]]></title>
        <id>etc/key-binding</id>
        <link href="https://zamoca.space/etc/key-binding"/>
        <updated>2024-06-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[코드 스니펫을 VSCode에 단축키로 등록해 자동입력하기]]></summary>
        <content type="html"><![CDATA[
> https://code.visualstudio.com/docs/editor/userdefinedsnippets#_assign-keybindings-to-snippets

VSCode에서는 커스텀 스니펫과 키 바인딩 기능을 제공한다.

이를 활용하면 자주 사용하는 코드나 텍스트를 단축키나 단축어로 쉽게 입력할 수 있다.
블로그 포스트를 작성 시 매번 frontmatter나 excerpt 키워드를 복사하여 붙여넣는 번거로움을 줄이기 위해 VSCode의 이 기능을 사용해 보기로 했다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="VSCode"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdownlint - 마크다운 linting 도구]]></title>
        <id>etc/markdown-lint</id>
        <link href="https://zamoca.space/etc/markdown-lint"/>
        <updated>2024-06-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Markdownlint는 VSCode 확장 프로그램 중 하나로, 마크다운 형식의 파일을 일관성있게 작성하도록 도와주는 도구다.

![https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint](https://github.com/Zamoca42/next-blog/assets/96982072/13d22865-eed5-46b1-b2bd-503f81cafa12)

블로그를 작성할 때 주로 사용하고있고, VSCode 설정에서 `codeActionsOnSave` 설정 시 자동으로 규칙과 어긋난 부분을 수정한다.

```diff-json:settings.json
    //...
    "editor.codeActionsOnSave": {
        "source.fixAll": "explicit",
+       "source.fixAll.markdownlint": "explicit"
    },
    //...
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Markdown"/>
        <category label="VSCode"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[블로그 마크다운 문법 정리]]></title>
        <id>etc/markdown</id>
        <link href="https://zamoca.space/etc/markdown"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
<!-- markdownlint-disable -->

## 마크다운(Markdown)이란?

마크다운(Markdown)은 텍스트 기반의 가벼운 마크업 언어 중 하나로, 읽기 쉽고 쓰기 쉬운 문법을 가지고 있다.

마크다운은 HTML로 변환이 가능하며, 다양한 플랫폼과 프로그램에서 지원되고 있다.

마크다운을 사용하면 **간단한 문법**으로 서식이 있는 문서를 작성할 수 있다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Markdown"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[프로메테우스 - 그라파나 in Django]]></title>
        <id>etc/infra/grafana-prometheus-in-django</id>
        <link href="https://zamoca.space/etc/infra/grafana-prometheus-in-django"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 왜 그라파나와 프로메테우스 인가?

Datadog, Sentry와 같이 여러 데이터를 시각화해서 보여주는 앱들이 많지만
그라파나와 프로메테우스는 오픈 소스 도구로 비용이 들지 않고 다양하게 커스터마이징할 수 있다는 장점이 있었다.
나는 프로젝트를 해오면서 모니터링 도구를 사용해본 적 없기 때문에 그라파나와 프로메테우스를 포토부스 프로젝트의 첫 모니터링 도구로 설정해보게 되었다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Monitoring"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[우분투에 node & npm 설치]]></title>
        <id>etc/infra/node-install</id>
        <link href="https://zamoca.space/etc/infra/node-install"/>
        <updated>2024-03-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로젝트의 서버는 NestJS를 사용하고 있다.
NestJS로 구성된 서버를 실행하려면 node와 npm이 있어야 패키지를 관리하고 실행할 수 있다.
하지만 기본적으로 EC2 인스턴스를 만들면 Node.js와 npm 등이 설치되어 있지 않다.

그래서 aws에서 ec2 인스턴스를 만들 때 기본 제공되는 unbuntu 이미지에 Node.js와 npm 설치하고
git clone으로 레포지토리까지 설정을 한 다음,
초기 설정한 볼륨을 이미지(AMI)로 만들어서 자동으로 생성된 인스턴스에 초기설정이 필요없게 만들려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Node"/>
        <category label="NPM"/>
        <category label="EC2"/>
        <category label="Linux"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[CI/CD란?]]></title>
        <id>etc/infra/github-actions/ci-cd</id>
        <link href="https://zamoca.space/etc/infra/github-actions/ci-cd"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> CI/CD 개념 부분은 참고 링크의 레드햇 기술블로그와 요즘 IT의 CI/CD 개념과 깃허브 리포지터리 생성하기 부분의 개념 부분을 참조했습니다.

CI/CD (Continuous Integration/Continuous Delivery)는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는
통합 지옥(integration hell)을 자동화하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법입니다.
CI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포입니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CI"/>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[EC2에 Django 서버 배포하기]]></title>
        <id>etc/infra/github-actions/ec2-deploy</id>
        <link href="https://zamoca.space/etc/infra/github-actions/ec2-deploy"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번 글에서는 GitHub Actions에서 AWS CodeDeploy에 전달하고 EC2에 Django 서버를 배포하는 것까지 진행해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Actions]]></title>
        <id>etc/infra/github-actions/github-actions</id>
        <link href="https://zamoca.space/etc/infra/github-actions/github-actions"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://docs.github.com/ko/actions - GitHub Actions 공식 문서

Github Actions에 대해 간단히 설명하면 테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼입니다.
레포지토리에서 push같은 이벤트가 일어날 때, workflow를 통해 작업이 실행되는 자동화 프로세스로 각 작업은 자체 가상머신을 사용하여 실행됩니다.

이번에는 GitHub Actions를 사용해서 AWS EC2에는 서버를 배포하고 S3에는 정적 웹페이지에 배포를 자동화 해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CI"/>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[S3에 정적 웹페이지 배포하기]]></title>
        <id>etc/infra/github-actions/s3-deploy</id>
        <link href="https://zamoca.space/etc/infra/github-actions/s3-deploy"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
AWS S3 버킷에 vue로 빌드한 페이지를 정적 웹 사이트로 호스팅할 수 있습니다.

- [Amazon S3를 사용하여 정적 웹 사이트 호스팅](https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/WebsiteHosting.html?icmpid=docs_amazons3_console)

S3 버킷을 정적 웹사이트로 호스팅하기 위해서는 다음과 같은 설정이 필요합니다.

1. 퍼블릭 액세스 설정
2. 버킷 정책 설정
3. CORS 설정

이렇게 버킷을 설정하는 방법을 알아보고 GitHub Actions에서 배포 설정을 자동화 해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="CD"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DevContainer - VSCode(IDE)에서 리눅스 환경으로 개발하고 디버깅하기]]></title>
        <id>etc/infra/docker/dev-container</id>
        <link href="https://zamoca.space/etc/infra/docker/dev-container"/>
        <updated>2024-02-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## DevContainer란 무엇인가?

> [VS Code로 컨테이너 안에서 개발하기](https://ssowonny.medium.com/vs-code%EB%A1%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%95%88%EC%97%90%EC%84%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-d8ed0950d69a)
>
> [Developing inside a Container - vscode 문서](https://code.visualstudio.com/docs/devcontainers/containers)

DevContainer는 주로 Visual Studio Code와 같은 통합 개발 환경(IDE)에서 사용되며,
Visual Studio Code의 확장 앱을 통해 구성할 수 있습니다.
이를 통해 프로젝트를 개발하는 동안 개발 환경을 컨테이너 내에서 실행하고 호스트 시스템과 분리시키는 것이 가능합니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Docker"/>
        <category label="Debug"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[자주 사용하는 git 명령어 모음]]></title>
        <id>etc/git/cheat-sheet</id>
        <link href="https://zamoca.space/etc/git/cheat-sheet"/>
        <updated>2024-04-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 설정

**vscode로 git 설정**

```shell
git config --global core.editor "code --wait"
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[필요한 디렉터리만 clone하기]]></title>
        <id>etc/git/git-sparse-checkout</id>
        <link href="https://zamoca.space/etc/git/git-sparse-checkout"/>
        <updated>2024-03-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
현재 프로젝트 레포지토리의 디렉터리 구조는 이렇게 되어있다.

> :file_folder: toeic  
> ├─ :file_folder: backend/  
> ├─ :file_folder: frontend/  
> ├─ package-lock.json  
> └─ package.json

GitHub 레포지토리에서 frontend 디렉터리를 제외한 나머지 파일 및 디렉터리를 clone해서 가져오려면 어떻게 해야할까?

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[merge]]></title>
        <id>etc/git/merge</id>
        <link href="https://zamoca.space/etc/git/merge"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
git에서 브랜치와 다른 브랜치를 합치는 명령어가 `merge`

## merge 명령어

브랜치와 다른 브랜치를 합치기 위해서 최종으로 합치고싶은 브랜치로 이동

예를 들어, `post`라는 브랜치와 `main`이라는 브랜치가 존재

`main`에 `post`를 합치고 싶다면 `main` 브랜치로 이동

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Git"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[DynamoDB 연결하기 with NestJS]]></title>
        <id>etc/db/dynamoose</id>
        <link href="https://zamoca.space/etc/db/dynamoose"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Nest에서는 TypeORM, Prisma, Mongoose 등 다양한 ORM을 사용할 수 있기 때문에
SQL이나 NoSQL 데이터베이스 모두 쉽게 연결할 수 있습니다.

이번 주제에서는 AWS의 대표적인 NoSQL 기반 데이터베이스인 DynamoDB를 Dynamoose를 이용해서 연결해보겠습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="DynamoDB"/>
        <category label="Dynamoose"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma - 인스턴스 경고 해결하기]]></title>
        <id>etc/db/prisma-instance</id>
        <link href="https://zamoca.space/etc/db/prisma-instance"/>
        <updated>2024-05-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
Next.js에서 Prisma를 사용하여 로컬 개발 환경에서 작업하다 보면, 터미널에 다음과 같은 경고 메시지가 나타나는 경우가 있다.

```txt
warn(prisma-client) There are already 10 instances of Prisma Client actively running.
```

이 글에서는 이 경고 메시지가 발생하는 이유와 해결 방법에 대해 알아보려고 한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Prisma"/>
        <category label="MySQL"/>
        <category label="PlanetScale"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prisma - relationMode 에러]]></title>
        <id>etc/db/prisma-relation-mode</id>
        <link href="https://zamoca.space/etc/db/prisma-relation-mode"/>
        <updated>2024-05-22T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
이번에는 MySQL 로컬환경에서 PlanetScale 서비스로 넘어가기 위한 설정을 할 때 겪었던 에러에 대해 다루려고 한다.

![VT10001 외래키 제약 에러 발생](https://github.com/Zamoca42/blog/assets/96982072/e0429b8d-12e9-45c8-9625-6d22189d91c1)

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Prisma"/>
        <category label="MySQL"/>
        <category label="PlanetScale"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[맛집 목록 가져와서 지도에 표시하기]]></title>
        <id>etc/db/query-range</id>
        <link href="https://zamoca.space/etc/db/query-range"/>
        <updated>2023-12-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
공공데이터로 맛집 목록을 받아와서 지도에 내 위치 주변 맛집을 보여주는 API를 만들었습니다.

> 해당 프로젝트 링크: https://github.com/pre-onboarding-backend-G/feed-me-baby

제가 맡은 부분은 전처리된 데이터를 가져와서 맛집 목록을 지도에 표시할 수 있게 반환하는 부분입니다.

여러 방법이 있겠지만 처음에는 맛집 목록을 내 위치 기준으로 범위만큼 위도나 경도를 빼거나 더해서 가져왔습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="NestJS"/>
        <category label="PostgreSQL"/>
        <category label="TypeORM"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeORM - DISTINCT]]></title>
        <id>etc/db/typeorm-distinct</id>
        <link href="https://zamoca.space/etc/db/typeorm-distinct"/>
        <updated>2024-01-26T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
TypeORM을 사용해서 개발하다보면 페이지네이션 처리를 해야하는 경우가 생긴다.
이 때 목록 조회 API를 구현하고 요청할 때 SQL문을 보면 SELECT 쿼리에 DISTINCT가 들어있는 경우가 있다.

![유저 목록 조회시 DISTINCT 쿼리가 생기는 것을 볼 수 있다.](https://github.com/Zamoca42/blog/assets/96982072/f109a7a3-0fe3-43da-9d7b-5cc149e79553)

SELECT DISTINCT 쿼리는 왜 생기는지 궁금하여 찾아보다가 나온 정보들을 이번 포스트에서 정리하려고한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Database"/>
        <category label="TypeORM"/>
        <category label="ORM"/>
        <category label="NestJS"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL - subquery]]></title>
        <id>etc/db/sql/sql-subquery</id>
        <link href="https://zamoca.space/etc/db/sql/sql-subquery"/>
        <updated>2024-02-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> https://youtu.be/lwmwlA2WhFc?si=Szgl3bDlly7CF266

서브쿼리(subquery)란 nested query 또는 inner query 라고 불리며
SELECT, INSERT, UPDATE, DELETE 쿼리문에 포함된 쿼리를 말한다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 1 ~ 5강]]></title>
        <id>etc/db/sql/sql</id>
        <link href="https://zamoca.space/etc/db/sql/sql"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 1 ~ 5강의 내용입니다

## 데이터 베이스를 조작하는 언어 SQL

- SQL은 '관계형 데이터베이스 관리 시스템(RDBMS)'을 조작할 때 사용한다.

- 관계형 데이터베이스
  - Oracle
  - DB2
  - SQL Server
  - PostgreSQL
  - MySQL
  - SQLite

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 6 ~ 10강]]></title>
        <id>etc/db/sql/sql2</id>
        <link href="https://zamoca.space/etc/db/sql/sql2"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 6 ~ 10강의 내용입니다

## 검색 조건 지정하기

데이터를 검색하는 방법에는 열을 지정하는 방법과 행을 지정하는 방법이 있습니다.

```sql
SELECT 열1, 열2 FROM 테이블명 WHERE 조건식
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[(SQL 첫걸음) 11 ~ 15강]]></title>
        <id>etc/db/sql/sql3</id>
        <link href="https://zamoca.space/etc/db/sql/sql3"/>
        <updated>2023-10-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> SQL 첫걸음 11 ~ 15강의 내용입니다

## 결과 행 제한하기

LIMIT 구로 결과 행을 제한하는 방법에 관해 알아보겠습니다.

```sql
SELECT 열명 FROM 테이블명 LIMIT 행수 [OFFSET 시작행]
```

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="SQL"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[백준 2748 - 피보나치 수]]></title>
        <id>etc/coding-test/boj-2748</id>
        <link href="https://zamoca.space/etc/coding-test/boj-2748"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
피보나치 수를 구할 때 동적계획법을 활용 해보겠습니다.

피보나치 수는 0과 1로 시작합니다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다.
그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 됩니다.

이를 점화식으로 나타내면 $F_n = F_{n-1} + F_{n-2}$ 이고 $n = 17$ 일 때 까지 피보나치 수를 써보면 다음과 같습니다.

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Boj"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[성격유형 검사하기 - Python]]></title>
        <id>etc/coding-test/programmers-mbti</id>
        <link href="https://zamoca.space/etc/coding-test/programmers-mbti"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로그래머스 [성격 유형 검사하기][personal] 문제입니다.

문제에서 각 지표는 4개 지표로 나눠집니다.

1. 라이언형(R), 튜브형(T)
2. 콘형(C), 프로도형(F)
3. 제이지형(J), 무지형(M)
4. 어피치형(A), 네오형(N)

예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다.

|   선택지    |            성격 유형 점수             |
| :---------: | :-----------------------------------: |
| 매우 비동의 |              네오형 3점               |
|   비동의    |              네오형 2점               |
| 약간 비동의 |              네오형 1점               |
|  모르겠음   | 어떤 성격 유형도 점수를 얻지 않습니다 |
|  약간 동의  |             어피치형 1점              |
|    동의     |             어피치형 2점              |
|  매우 동의  |             어피치형 3점              |

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Programmers"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[신고 결과 받기 - Python]]></title>
        <id>etc/coding-test/programmers-report</id>
        <link href="https://zamoca.space/etc/coding-test/programmers-report"/>
        <updated>2023-09-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
프로그래머스 [신고 결과 받기][report] 문제입니다

]]></content>
        <author>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </author>
        <category label="Codingtest"/>
        <category label="Programmers"/>
        <contributor>
            <name>추연규(Zamoca)</name>
            <email>yk@choo.ooo</email>
            <uri>https://zamoca.space</uri>
        </contributor>
    </entry>
</feed>