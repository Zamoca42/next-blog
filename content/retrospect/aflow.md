---
title: Aflow 프로젝트 회고
description: Aflow 프로젝트 회고입니다.
tag:
  - Retrospect
date: "2025-02-03"
---

Aflow는 기존의 레포지토리 트리 ASCII 변환 프로젝트를 확장하여, AI를 활용해 파일/폴더 구조를 분석하고 아키텍처 다이어그램으로 변환하는 프로젝트다.  
오픈소스에 기여하면서 코드를 열어보기 전에 어떤 구조인지 이해가 안되면 어떤 기능을 하는 코드인지 이해하기 어려웠던 적이 많았다.
README나 기술문서에 친절하게 아키텍쳐가 보여주는 경우도 있지만 없는 경우가 더 많았고, Claude에 트리 구조를 넣으면 생소한 프로젝트라도 맥락을 빠르게 이해할 수 있었기 때문에 자주 사용하게 되었다.

![Tauri 프로젝트 기술문서에 나와있는 아키텍쳐 예시](https://github.com/user-attachments/assets/6c74b6fa-b4e5-4d63-8478-e313cfa52b74)

Claude는 Anthropic이 개발한 AI 모델로, 아티팩트 기능을 통해 Mermaid.js를 사용해 레포지토리 트리 구조를 넣으면 다이어그램으로 보여주는 기능이 있었다.
하지만 Mermaid 문법을 보여줄 때 3번 중 1번은 오류가 발생하고 매번 트리구조를 복사해서 붙여넣기를 해야하는 불편함도 있었다.
이 기능을 확장해서 GitHub의 레포지토리 트리를 매번 복사/붙여넣기할 필요없이 다이어그램으로 보여주는 자동화 도구를 만들고 싶었다.

그래서 3가지 중점을 두고 프로젝트를 계획했다.

1. 트리 구조를 복사해서 매번 붙여넣기를 하지 않도록 자동화
2. 일관성 있는 Mermaid 문법으로 출력
3. GitHub에서 비공개 레포지토리도 가져와 다이어그램으로 출력

# 기술 스택 선정

이번에 프로젝트를 진행하면서 사용하게된 기술 스택은 다음과 같다.

- 프레임워크: Next.js 15
- 라이브러리: Mermaid.js, Langchain.js
- 툴: Vercel, Google Gemini 1.5, Github App
- DB: Redis (Vercel KV)

## Next.js

지금까지는 NestJS를 사용해서 프로젝트를 진행했는데 이번에는 Next.js를 사용해서 프로젝트를 진행했다.  
프로젝트 규모가 작고 데이터베이스도 필요하지않다고 생각했기도 하고 내가 사용한다는 가정으로 사용자수가 많다고 생각하지 않았다. Next.js에서 지원하는 서버 액션만으로 충분히 구현이 가능하고 자바스크립트에 대한 경험이 있었기 때문에 백엔드와 프론트엔드까지 커버 가능하고 소규모로 시작하기 좋은 Next.js를 사용하는 것이 좋다고 생각했다.

## Langchain.js vs Vercel AI SDK

Claude에는 아티팩트라는 기능을 개선해보기 위한 프로젝트이기 때문에 AI SDK를 사용해야했는데 Vercel AI SDK와 Langchain.js 중 선택해야했다.  
최종적으로는 Langchain.js을 선택했는데 Vercel AI SDK에서 AI API 출력에 일관성이 없었기 때문에 디버깅이 어려웠다.

예를 들어, Vercel AI SDK에서 프롬프트와 출력 포맷을 설정해도 API를 ChatGPT에서 Claude로 바꾸면 엉뚱한 대답을 내놓거나 출력한 포맷이 API마다 달라진다.
API를 바꿀때마다 프롬프트와 출력 포맷을 다시 설정해야하는 불편함이 있었다.

여러가지 API를 비교해보면서 사용하기에는 Vercel AI SDK는 제약이 많아보였기 때문에 Langchain.js를 사용하는 것이 좋다고 판단했다. Langchain.js은 API마다 chaining 방법은 다르지만 API를 변경해도 프롬프트와 출력 포맷을 다시 설정할 필요가 없었기 때문에 프로젝트를 진행하는데 편리했다.

## 시각화 라이브러리

웹 환경에서 렌더링할 수 있는 텍스트 기반 시각화 라이브러리에 Mermaid.js 외에 다른 대안은 없는지 궁금했었다.
Mermaid.js 외에 Graphviz, PlantUML를 발견하게 되어 세 라이브러리를 비교해봤는데, 결국 웹에서 바로 실행 가능하고 레퍼런스가 많은 Mermaid.js가 가장 좋다고 판단했다.

### Mermaid.js vs Graphviz vs PlantUML

| 기능                          | Mermaid.js           | Graphviz      | PlantUML       |
| ----------------------------- | -------------------- | ------------- | -------------- |
| 웹 환경 지원                  | ✅ (JavaScript 지원) | ❌ (CLI 필요) | ❌ (Java 필요) |
| 레퍼런스                      | ✅                   | ❌            | ❌             |
| 문법 직관성                   | 가장 직관적          | 명령어 복잡   | 중간 수준      |
| 레이아웃 자동조정             | ❌                   | ✅            | ❌             |
| 간트 차트 & 시퀀스 다이어그램 | ✅                   | ❌            | ✅ (복잡함)    |

## AI API

AI API는 프로젝트를 진행하면서 사용한 것은 다음과 같다.

- Claude 3.5 Sonnet, haiku
- Google Gemini 1.5
- ChatGPT-4o
- Huggingface (QwQ-32B-Preview)

AI API를 도입할 때 고려한 점은 응답 시간, 비용, 응답하는 결과, Mermaid 문법 오류 횟수를 고려했다.
같은 프롬프트와 레포지토리를 사용해서 입력 토큰을 일정하게 만들어서 10회 이상 요청을 보내서 테스트해보았다.

| 요청 1회당 평균   | Claude 3.5 Sonnet | Cluade 3.5 Haiku | Google Gemini 1.5 | ChatGPT-4o  | QwQ-32B-Preview |
| ----------------- | ----------------- | ---------------- | ----------------- | ----------- | --------------- |
| 응답 시간         | 8s                | 12s              | 5s                | 12s         | 40s             |
| 출력 비용         | 30원              | 10원             | 12원              | 35원        | 무료            |
| 출력 토큰수       | 450               | 280              | 350               | 500         | -               |
| Mermaid 문법 오류 | 2/10회 발생       | 2/10회 발생      | 1/10회 발생       | 3/10회 발생 | -               |

QWQ-32B-Preview는 무료지만 응답 시간이 길고 출력 오류가 많았고, Sonnet은 제일 만족스러운 응답이였지만 비용이 부담된다는 단점이 있었다.
Haiku는 비용이 저렴하지만 가격대비 출력 토큰 수가 적었다.
최종으로 Google Gemini 1.5를 사용하기로 했는데, 응답시간 대비 비용이 저렴하고 출력 토큰 수가 많아서 사용하기 좋았다.

## Vercel

Vercel은 Next.js 프로젝트를 배포하기 좋은 클라우드 플랫폼이다. CI/CD가 내장되어 있어 코드를 푸시하면 자동으로 배포된다.
자동으로 서버 리소스를 스케일링하며, 사용량 기반 요금제를 사용하기 때문에 트래픽이 증가하면 비용이 상승할 수 있지만,  
소규모 프로젝트라면 무료 플랜에서도 충분히 사용할 수 있다.
다만, AWS처럼 세밀한 보안 권한 관리(IAM) 기능은 제공하지 않기 때문에, 특정한 관리자 역할과 접근 권한을 설정해야 하는 경우에는 AWS, GCP 등의 다른 클라우드 플랫폼을 고려해야 한다.

## Redis

먼저 Redis의 도입하기 전에 프로젝트를 사용자가 생기면 구독 플랜으로 전환 할지 무료인 대신 광고를 추가할지 고민했다.
구독 플랜을 고려하면 구독자 관리를 위한 데이터베이스가 필요하고 관리할 일이 많아진다. 그것보다는 나를 제외한 꾸준한 사용자가 있는게 아니기 때문에 무료 플랜을 사용하고 API 호출 비용을 줄이는 것이 좋다고 판단했다.

### 메모리 vs ioRedis vs Vercel KV

API 호출 비용을 줄이는 방법으로 Cache를 도입하기로 했다. 메모리 기반 캐시와 Redis 캐시 중 선택해야했는데  
메모리 기반 캐시는 서버가 재시작되거나 크래시될 경우 데이터가 사라지는 문제가 있어, API 호출 비용 절감을 위해 지속적인 캐싱이 필요한 이 프로젝트에는 Redis가 더 적합했다.

ioRedis와 Vercel KV 중 선택해야했는데 ioRedis는 TCP 프로토콜을 사용하고 Node.js 런타임을 사용해야 하기 때문에 Edge 런타임을 사용하는 서버리스 환경에서는 사용할 수 없었다.  
Vercel KV는 Upstash와 같은 클라우드 플랫폼을 사용하고 HTTP 프로토콜로 요청을 보내기 때문에 서버가 항상 동작하고 있지 않아도 캐시를 사용할 수 있다.

네, AI 출력 포맷 오류 부분을 더 명확하게 다듬어보겠습니다:

# 프로젝트 진행 과정에서 마주친 문제점들과 해결 방법

## 1. AI 출력 포맷 오류

### 문제점

처음에는 AI에게 직접 Mermaid 문법으로 출력하도록 프롬프트를 작성했으나, 다음과 같은 문제가 발생했다.

- 들여쓰기나 괄호 짝 맞추기 등 문법 오류가 빈번히 발생
- API마다 출력 포맷이 일관성이 없어서 파싱하기 어려움
- 복잡한 구조일수록 오류 발생 확률이 높아짐

### 해결 방법

1. JSON 포맷으로 structured output 적용

   - AI 출력을 JSON 스키마로 강제하여 구조화된 데이터 확보
   - 예시:
     ```json
     {
       "nodes": ["src", "components", "utils"],
       "flows": [
         { "source": "src", "target": "components" },
         { "source": "src", "target": "utils" }
       ]
     }
     ```

2. JSON to Mermaid 변환 스크립트 구현
   - 검증된 JSON 데이터를 Mermaid 문법으로 변환하는 별도 파서 개발
   - 문법 오류 가능성 제거
   - 일관된 다이어그램 스타일 유지

## 2. Redis 콜백 에러

Langchain.js에서 Redis 캐시와 비율 제한(Rate Limiting)을 함께 사용할 때 콜백 처리에서 문제가 발생했다.

### 문제점

```typescript
const architecture = await model.pipe(parser).invoke(formattedPrompt, {
  callbacks: [ratelimitHandler], // unhandledRejection: UpstashRatelimitError: Request limit reached!
});
```

- 모델 호출 시 콜백에서 비율 제한 관련 메세지가 제대로 처리되지 않음
- 캐시와 비율 제한이 동시에 적용될 때 예상치 못한 동작 발생

### 해결 방법

1. 콜백 구조 최적화

   ```typescript
   const model = new ChatGoogleGenerativeAI({
     model: "gemini-1.5-flash",
     temperature: 1.0,
     cache,
     callbacks: [ratelimitHandler], // 모델 레벨에서 콜백 적용
   });
   ```

2. 에러 처리 개선
   - 제한 도달 시 사용자 메세지 제공
   - 제한 도달시 버튼 비활성화 및 시간 제한 적용

## 3. GitHub 인증 시스템 개선

처음에는 GitHub OAuth를 사용했으나, 보안과 권한 관리 측면에서 더 나은 방법을 찾아야 했다.

### 문제점

- OAuth의 광범위한 권한 요청으로 인한 보안 우려
- 비공개 레포지토리 접근 권한 관리의 어려움
- 사용자별 권한 제어의 한계

### 해결 방법

1. GitHub App으로 전환

   - 비공개 레포지토리에 읽기 권한만 요청하도록 스코프 최적화
   - 레포지토리 단위의 세밀한 권한 제어 구현

2. 보안 강화

   - 접근 토큰 암호화 저장
   - 권한 검증 로직 추가
   - 주기적인 토큰 갱신 구현

# 프로젝트를 통해 얻은 성장

- 캐싱 전략 수립을 통한 비용 최적화 경험
- 명확한 목표 설정의 중요성 인식
- 기술 스택 선정 시 고려해야 할 다양한 요소들에 대한 이해

# 향후 개선 계획

1. AI 모델 다각화

   - 사용자가 선호하는 AI 모델을 선택할 수 있는 옵션 제공
   - 비용 효율적인 API 사용을 위한 모델 선택 가이드 제공

2. 다이어그램 커스터마이징

   - 사용자가 선호하는 다이어그램 스타일 저장 기능
   - Mermaid 코드 수정 UI 제공
   - 다이어그램 PNG 파일로 다운로드 기능 추가

3. 협업 기능

   - 팀원들과 다이어그램 공유 기능
   - 다이어그램에 대한 코멘트 기능
   - 버전 히스토리 관리

4. 모니터링 강화

   - 에러 트래킹 시스템 도입
   - 사용자 행동 분석을 통한 UX 개선
   - API 사용량 모니터링 대시보드 구축
