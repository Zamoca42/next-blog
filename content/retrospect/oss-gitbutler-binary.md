---
title: "GitButler - 이미지 미리보기 기능 기여 후기"
tag:
  - GitButler
  - Git
  - Open-Source
date: "2024-10-21"
---

> 관련 이슈 1: https://github.com/gitbutlerapp/gitbutler/issues/2752  
> 관련 이슈 2: https://github.com/gitbutlerapp/gitbutler/issues/3093

이번 후기는 GitButler에서 바이너리 파일(이미지, 폰트파일 등)을 미리보기 기능을 구현한 것에 대한 후기입니다.

![UI에서 미리보기 없이 Binary content not shown을 출력한다](https://github.com/user-attachments/assets/bc6269bd-14c0-4874-afc5-526d8ca82dfa)

관련 이슈를 살펴보면 바이너리 파일을 미리보기 기능을 구현하는 것에 대한 이슈가 있었습니다.  
UI에서 이미지는 미리보기 기능, 이미지 외의 파일에 대한 사이즈 정보를 보여주는 기능을 구현하는 것이 목표였습니다.

<!-- end -->

처음에는 프론트에서 로컬 파일의 경로를 읽어와서 보여주면 된다고 생각했습니다.  
하지만 프론트에서 미리보기를 구현하는건 단순한 문제였고, 백엔드에서 파일을 가져오는 방법에 대한 문제가 고민이 더 필요했습니다.

## 문제 파악과 협업 과정

> 해결 시도: https://github.com/gitbutlerapp/gitbutler/pull/4852  
> 관련 이슈 3: https://github.com/gitbutlerapp/gitbutler/issues/4957
> 최종 구현: https://github.com/gitbutlerapp/gitbutler/pull/5089

### 첫 번째 접근 방식과 보안 문제

처음에는 프론트엔드에서 로컬 파일을 직접 가져와 보여주는 방법을 시도했습니다. Tauri에서는 [convertFileSrc](https://v1.tauri.app/v1/api/js/tauri/#convertfilesrc) API를 사용하면 로컬 파일 경로를 브라우저에서 표시 가능한 URL로 변환할 수 있었습니다.

이 접근 방식은 기술적으로 가능했고 일부 메인테이너는 긍정적이였지만, 곧 보안 문제가 지적되었습니다. 문제는 이 방식이 `$HOME` 디렉토리 전체에 접근 권한을 필요로 한다는 점이었습니다.  
이렇게 광범위한 파일 시스템 접근은 "**경로 조작 공격**"이나 권한 에스컬레이션 같은 보안 취약점을 만들 수 있었습니다.  

이러한 피드백을 받고 접근 방식을 완전히 재고해야 했습니다.  
프론트엔드에 직접 파일 시스템 접근 권한을 주는 대신, 백엔드에서 안전하게 파일을 제공하는 방식이 필요했습니다.  
마침 다른 메인테이너가 Git 저장소의 pull request template 파일을 가져오는 함수를 구현하고 있었고, 이 접근법을 응용할 수 있었습니다.

### Git 파일 조회 순서 개선

PR #5089에서 구현을 진행하면서, Git의 파일 조회 순서에 대한 중요한 피드백을 받았습니다.  
초기 구현에서는 Git 트리(commit된 파일)를 먼저 조회한 후 워크트리를 조회하는 방식이었는데, 이는 Git의 표준적인 동작과 일치하지 않는다는 지적이었습니다.

Git의 일반적인 동작은 다음 순서로 파일을 찾는 것이 일반적입니다.

1. 워크트리(작업 디렉토리)
2. 인덱스(스테이징 영역)
3. HEAD 트리(마지막 커밋)

이 피드백을 반영하여 파일 조회 로직을 재설계했고, 덕분에 미추적(untracked) 파일과 같은 다양한 상태의 파일을 제대로 표시할 수 있게 되었습니다.  

### 코드 구조 개선과 책임 분리

코드 리뷰 과정에서 받은 또 다른 중요한 피드백은 `read_file_from_workspace` 함수가 너무 많은 책임을 가지고 있다는 점이었습니다.  
이 함수는 워크트리, 인덱스, Git 트리 등 여러 소스에서 파일을 읽어야 했고, 이로 인해 코드가 복잡해지고 있었습니다.  

메인테이너의 제안에 따라 코드를 두 개의 함수로 분리했습니다.  
- `read_file_from_workspace`: 워크스페이스 파일 조회(미추적, 수정된 파일 등)
- `read_file_from_tree`: Git 트리에서 파일 조회(커밋된 파일)

### 다양한 파일 상태 처리

개발 과정에서 또 하나의 도전은 Git 저장소에서 파일을 조회할 때 다양한 상태의 파일을 어떻게 처리할지였습니다.  
특히 다음과 같은 상태를 고려해야 했습니다.

1. 미추적(untracked) 상태: 새로 추가되었지만 아직 Git에 추가되지 않은 파일
2. 커밋된(committed) 상태: Git에 이미 추가된 파일
3. 삭제된(deleted) 상태: 워크트리나 인덱스에서 삭제된 파일

처음에는 미추적 바이너리 파일을 미리보기할 수 없는 문제가 있었는데, 이는 다른 PR(#5111)에서 개발 중이던 기능을 참고하여 해결했습니다.  
`status_file` 함수를 활용해 파일의 상태를 확인하고 각 상태에 맞게 처리하는 로직을 구현했습니다.  

특히 이미지 파일이 커밋된 후 삭제되더라도 이전 커밋을 조회할 때 해당 이미지를 볼 수 있어야 했습니다.  
이러한 다양한 상태 처리를 통해 Git의 어떤 상태에서도 바이너리 파일을 올바르게 표시할 수 있게 되었습니다.

![삭제된 이미지의 이전 커밋 조회](https://github.com/user-attachments/assets/b20ad0bf-8074-4f77-8b54-b135aeb2b944)

이러한 협업 과정과 피드백을 통해 처음 생각했던 것보다 더 안전하고 효율적인, 그리고 다양한 파일 상태를 적절히 처리할 수 있는 솔루션을 구현할 수 있었습니다.

## 기술적 구현 세부 사항

앞서 설명한 문제 파악과 협업 과정을 바탕으로, PR #5089에서 최종적으로 다음과 같은 기술적 구현을 완성했습니다.  

### 개발 환경 설정의 어려움

Rust로 구현을 시작하면서 가장 먼저 맞닥뜨린 어려움은 개발 환경 설정이었습니다. Rust 패키지를 설치하는 과정에서 예상보다 많은 오류를 만났습니다.  

![Rust 패키지 설치 오류](https://github.com/user-attachments/assets/6205275c-1f13-48a9-871b-e0ca404f36a3)

여러 시도 끝에 Rust 버전을 nightly로 설정하고 패키지를 설치하니 오류가 해결되었습니다.   
또한 macOS와 Windows에서는 서로 다른 오류가 발생하여 크로스 플랫폼 개발의 어려움도 경험했습니다.  
이런 불편함에도 불구하고, Rust의 컴파일 타임 오류 검사는 런타임 오류를 크게 줄여주는 장점이 있었습니다.  

### 바이너리 파일 데이터 구조 설계

바이너리 파일 정보를 프론트엔드에 전달하기 위해 다음과 같은 데이터 구조를 설계했습니다.

```Rust
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct FileInfo {
    pub content: String,         // Base64로 인코딩된 파일 내용
    pub name: Option<String>,    // 파일 이름
    pub size: Option<usize>,     // 파일 크기(바이트)
    pub mime_type: Option<String>, // MIME 타입(이미지 등 구분용)
    pub status: FileStatus,      // 파일 상태(untracked, modified, deleted 등)
}
```

이 구조체는 파일의 내용뿐만 아니라 메타 정보까지 포함하여 프론트엔드에서 다양한 처리를 할 수 있도록 했습니다.  
특히 `mime_type` 필드는 `infer` 크레이트를 사용해 바이너리 데이터를 분석하여 파일 유형을 자동으로 감지하는 방식으로 구현했습니다.  

### 프론트엔드 구현

프론트엔드에서는 백엔드에서 받은 바이너리 데이터를 적절히 표시하는 작업을 했습니다.  
특히 파일 크기를 사용자 친화적으로 표시하는 기능과 이미지 파일일 경우 미리보기를 제공하는 기능을 구현했습니다.  

```javascript
// 파일 크기 포맷팅 함수
function formatFileSize(bytes: number): string {
  const KB = 1024;
  const MB = 1024 ** 2;
  const GB = 1024 ** 3;
  
  if (bytes < KB) return bytes + " B";
  else if (bytes < MB) return (bytes / KB).toFixed(1) + " KB";
  else if (bytes < GB) return (bytes / MB).toFixed(1) + " MB";
  else return (bytes / GB).toFixed(1) + " GB";
}

// 이미지 미리보기 컴포넌트
<div class="hunks">
  {#if isBinary}
    {#if fileInfo.mimeType && fileInfo.content}
      <img src="data:{fileInfo.mimeType};base64,{fileInfo.content}" 
           alt={fileInfo.name} />
    {/if}
    {#if fileInfo.status === 'deleted'}
      <p>File has been deleted</p>
    {:else}
      <p>Size: {formatFileSize(fileInfo.size || 0)}</p>
    {/if}
  {/if}
</div>
```

## 기여 후기

![0.13 버전부터 배포되어 미리보기 기능이 추가되었다](https://github.com/user-attachments/assets/4cdd20b2-1f3a-4519-9f90-b1d74cd506d9)

### 오픈소스 협업 배우기

이번 기여 과정에서 오픈소스에서 협업 방법에 대해 많이 배웠습니다.  

- **명확한 커뮤니케이션**:  
   문제와 해결 시도를 구체적으로 설명하고 스크린샷을 활용하는 것이 중요했습니다. 특히 바이너리 파일 처리와 같은 복잡한 주제를 설명할 때는 시각적 자료가 큰 도움이 되었습니다.
- **피드백 수용하기**:  
   초기에 보안 관련 피드백을 받았을 때 방어적이 되지 않고 이를 배움의 기회로 받아들였습니다.
- **관련 작업 참조하기**:  
   다른 PR(#5111, #4850)에서 배운 내용을 적용하고 공유함으로써 프로젝트의 지식을 활용했습니다. 특히 untracked 파일 처리 문제를 해결할 때 다른 PR의 접근법이 큰 도움이 되었습니다.
- **논리적 단위로 작업하기**:  
   변경사항을 작고 논리적인 단위로 나누어 리뷰어가 이해하기 쉽게 만들었습니다. 파일 조회 개선, 바이너리 파일 파싱, UI 개선 등을 분리하여 작업했습니다.
- **질문의 중요성**:  
   Git의 파일 조회 메커니즘이나 보안 접근 방식에 확신이 없을 때 적극적으로 질문했습니다. 이는 기술적 논의로 이어졌고 결국 더 나은 설계를 만들 수 있었습니다.

### Rust를 사용하며 느낀점

1. 강력한 컴파일러와 타입 시스템

   - 소유권 규칙을 지키지 않으면 컴파일 단계에서 오류 발생
   - 패키지 의존성 문제를 빌드 전에 감지
   - 상세한 오류 메시지로 디버깅이 수월함

2. 메모리 안전성

   - 소유권과 대여 개념으로 메모리 누수 방지
   - 컴파일 타임에 스레드 안전성 보장
   - null 또는 undefined 문제를 Option 타입으로 안전하게 처리

3. 생태계와 도구

   - Cargo를 통한 편리한 패키지 관리
   - infer 같은 유용한 커뮤니티 패키지 활용
   - rust-analyzer의 강력한 IDE 지원

4. 활성화된 커뮤니티

   - Discord를 통한 실시간 질문과 빠른 피드백
   - 메인테이너들의 적극적인 리뷰와 대응
   - 상세한 문서화와 예제 코드 공유

다만 처음에는 소유권 개념과 라이프타임 이해가 어려웠고, 컴파일러와 싸우는 시간이 많았습니다. 하지만 이런 제약사항들이 오히려 오류 없는 코드를 작성하는데 도움이 되었다고 생각합니다.
